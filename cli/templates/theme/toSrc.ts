
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => { 
  
  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Input/Text.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Input/Text.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Input.Text exposing (..)\n\n{-|\n\n@docs text, search\n\n@docs with\n\n@docs view\n\n-}\n\nimport Ui\nimport Ui.Dropdown\nimport Ui.Input\nimport Ui.Theme\n\n\ntype TextInput msg\n    = TextInput (Details msg)\n\n\ntype alias Details msg =\n    { value : String\n    , onChange : String -> msg\n    , onSubmit : Maybe msg\n    , placeholder : String\n    }\n\n\ntext :\n    { onChange : String -> msg\n    , text : String\n    }\n    -> Ui.Element msg\ntext options =\n    TextInput\n        { value = options.text\n        , onChange = options.onChange\n        }\n\n\nsearch :\n    { onSubmit : msg\n    , onChange : String -> msg\n    , text : String\n    , results : List SearchResult\n    }\n    -> Ui.Element msg\nsearch options =\n    TextInput\n        { value = options.text\n        , onChange = options.onChange\n        }\n\n\nview : TextInput msg -> Ui.Element msg\nview (TextInput details) =\n    Ui.Input.search\n        [ Ui.Theme.border.small\n        , Ui.below\n            (viewResults options.results)\n        ]\n        { onChange = options.onChange\n        , text = options.text\n        , placeholder =\n            Just (Ui.Input.placeholder [] (Ui.text details.placeholder))\n        , label =\n            Ui.Input.labelHidden options.label\n        }\n\n\ntype alias SearchResult =\n    { name : String\n    , group : String\n    , url : String\n    }\n\n\nviewResults : List SearchResult -> Ui.Element msg\nviewResults results =\n    case results of\n        [] ->\n            Ui.none\n\n        _ ->\n            let\n                groups =\n                    groupWhile\n                        (\\one two ->\n                            one.group == two.group\n                        )\n                        results\n            in\n            Ui.column\n                [ Ui.Theme.border.small\n                , Ui.Theme.padding.sm\n                , Ui.width Ui.fill\n                , Ui.Theme.spacing.sm\n                ]\n                (List.map\n                    (\\( top, others ) ->\n                        Ui.column [ Ui.width Ui.fill, Ui.Theme.spacing.sm3 ]\n                            [ Ui.el\n                                [ Ui.ellipsis\n                                , Ui.width Ui.fill\n                                , Ui.Theme.font.small\n                                ]\n                                (Ui.text top.group)\n                            , Ui.column [ Ui.width Ui.fill, Ui.Theme.spacing.sm2 ]\n                                (List.map\n                                    (\\item ->\n                                        Ui.el\n                                            [ Ui.link item.url\n                                            , Ui.ellipsis\n                                            , Ui.width Ui.fill\n                                            ]\n                                            (Ui.text item.name)\n                                    )\n                                    (top :: others)\n                                )\n                            ]\n                    )\n                    groups\n                )\n\n\ngroupWhile : (a -> a -> Bool) -> List a -> List ( a, List a )\ngroupWhile isSameGroup items =\n    List.foldr\n        (\\x acc ->\n            case acc of\n                [] ->\n                    [ ( x, [] ) ]\n\n                ( y, restOfGroup ) :: groups ->\n                    if isSameGroup x y then\n                        ( x, y :: restOfGroup ) :: groups\n\n                    else\n                        ( x, [] ) :: acc\n        )\n        []\n        items\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Table/Column.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Table/Column.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Table.Column exposing\n    ( text\n    , int, dollars\n    , date, dateTime\n    )\n\n{-|\n\n@docs text\n\n@docs int, dollars\n\n@docs date, dateTime\n\n-}\n\nimport Time\nimport Ui.Table\nimport Ui.Theme\n\n\n{-| Standard header styling.\n\nThis isn't exposed for a reason! We want to keep this detail internal to this module so there's one place where headers are styled.\n\n-}\nheader : String -> Ui.Table.Header msg\nheader label =\n    Ui.Table.cell\n        [ Ui.background Ui.Theme.colors.grey100\n        , Ui.Font.bold\n        ]\n        (Ui.text label)\n\n\n{-| Standard cell styling\n-}\ncell : List (Ui.Attribute msg) Ui.Element msg -> Ui.Table.Cell msg\ncell attrs content =\n    Ui.Table.cell attrs\n        content\n\n\n{-| -}\ntext :\n    { header : String\n    , toText : data -> String\n    }\n    -> Ui.Table.Column state data msg\ntext options =\n    Ui.Table.column\n        { header = header options.header\n        , view =\n            \\data ->\n                cell [] (Ui.text (options.toText data))\n        }\n\n\n\n{-|-}\nint :\n    { header : String\n    , toInt : data -> Int\n    }\n    -> Ui.Table.Column state data msg\nint options ==\n    number \n        { header = options.header\n        , toFloat = options.toInt >> toFloat\n        , format = { currency = Nothing, decimalPlaces = 0 }\n        }\n\n\n{-|-}\ndollars :\n    { header : String\n    , toFloat : data -> Float\n    }\n    -> Ui.Table.Column state data msg\ndollars options ==\n    number \n        { header = options.header\n        , toFloat = options.toFloat\n        , format = { currency = Just \"$\", decimalPlaces = 2 }\n        }\n\n\n{- Number cell implementation -}\n\n\ntype alias NumberFormat =\n    { currency : Maybe String\n    , decimalPlaces : Int\n    }\n\n\n{-| -}\nnumber :\n    { header : String\n    , toFloat : data -> Float\n    , format : NumberFormat\n    }\n    -> Ui.Table.Column state data msg\nnumber options =\n    Ui.Table.column\n        { header =\n            header options.header\n        , view =\n            \\data ->\n                cell\n                    [ Ui.Font.alignRight\n                    , Ui.Font.variants\n                        [ Ui.Font.tabularNumbers ]\n                    ]\n                    (Ui.text (formatFloat options.format (options.toFloat data)))\n        }\n\n\nformatFloat : NumberFormat -> Float -> String\nformatFloat format float =\n    case format.currency of\n        Just currency ->\n            currency ++ floatToString format float\n\n        Nothing ->\n            floatToString format float\n\n\nfloatToString : NumberFormat -> Float -> String\nfloatToString format float =\n    if max 0 format.decimalPlaces == 0 then\n        String.fromInt (floor float)\n\n    else\n        let\n            topString =\n                String.fromInt (floor float)\n                    -- Add commas as a thousands separator\n                    -- We could extend the formatter to allow for switching the period and commas\n                    -- Which is commonly used in places like France and Germany.\n                    |> String.foldr\n                        (\\char ( count, gathered ) ->\n                            if count == 3 then\n                                ( 1, Char.toString char ++ \",\" ++ gathered )\n\n                            else\n                                ( count + 1, Char.toString char ++ gathered )\n                        )\n                        ( 1, \"\" )\n                    |> Tuple.second\n\n            multiplier =\n                10 ^ format.decimalPlaces\n\n            tail =\n                floor ((float - toFloat (floor float)) * multiplier)\n        in\n        topString ++ \".\" ++ String.fromInt tail\n\n\n{-| -}\ntype DateFormat\n    = Date\n    | DateTime\n\n\n{-| -}\ndate :\n    { header : String\n    , toTimeZone : state -> Time.Zone\n    , toDate : data -> Time.Posix\n    }\n    -> Ui.Table.Column state data msg\ndate options =\n    dateCell\n        { header = options.header\n        , toTimeZone = options.toTimeZone\n        , toDate = options.toDate\n        , format = Date\n        }\n\n\n{-| -}\ndateTime :\n    { header : String\n    , toTimeZone : state -> Time.Zone\n    , toDate : data -> Time.Posix\n    }\n    -> Ui.Table.Column state data msg\ndateTime options =\n    dateCell\n        { header = options.header\n        , toTimeZone = options.toTimeZone\n        , toDate = options.toDate\n        , format = DateTime\n        }\n\n\n\n{- Date Cell Implementation -}\n\ndateCell :\n    { header : String\n    , toTimeZone : state -> Time.Zone\n    , toDate : data -> Time.Posix\n    , format : DateFormat\n    }\n    -> Ui.Table.Column state data msg\ndateCell options =\n    Ui.Table.columnWithState\n        { header =\n            \\state ->\n                header options.header\n        , view =\n            \\index state data ->\n                cell []\n                    (Ui.text (formatDate options.format (options.toTimeZone state) (options.toDate data)))\n        }\n\n\nformatDate : DateFormat -> Time.Zone -> Time.Posix -> String\nformatDate dateFormat zone posix =\n    case dateFormat of\n        Date ->\n            toMonthName (Time.toMonth zone time)\n                ++ \" \"\n                ++ String.fromInt (Time.toDay zone time)\n                ++ \", \"\n                ++ String.fromInt (Time.toYear zone time)\n\n        DateTime ->\n            toMonthName (Time.toMonth zone time)\n                ++ \" \"\n                ++ String.fromInt (Time.toDay zone time)\n                ++ \", \"\n                ++ String.fromInt (Time.toYear zone time)\n                ++ \" \"\n                ++ String.fromInt (Time.toHour zone time)\n                ++ \":\"\n                ++ String.fromInt (Time.toMinute zone time)\n                ++ \":\"\n                ++ String.fromInt (Time.toSecond zone time)\n\n\ntoMonthName : Time.Month -> String\ntoMonthName month =\n    case month of\n        Time.Jan ->\n            \"Jan\"\n\n        Time.Feb ->\n            \"Feb\"\n\n        Time.Mar ->\n            \"Mar\"\n\n        Time.Apr ->\n            \"Apr\"\n\n        Time.May ->\n            \"May\"\n\n        Time.Jun ->\n            \"Jun\"\n\n        Time.Jul ->\n            \"Jul\"\n\n        Time.Aug ->\n            \"Aug\"\n\n        Time.Sep ->\n            \"Sep\"\n\n        Time.Oct ->\n            \"Oct\"\n\n        Time.Nov ->\n            \"Nov\"\n\n        Time.Dec ->\n            \"Dec\"\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Button.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Button.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Button exposing\n    ( Button, primary, secondary\n    , withSmall, withLoading, withWidthFill\n    , view, row\n    )\n\n{-|\n\n@docs Button, primary, secondary\n\n\n## Options\n\n@docs withSmall, withLoading, withWidthFill\n\n\n## Viewing\n\n@docs view, row\n\n-}\n\nimport Ui\nimport Ui.Theme\nimport Ui.Theme.Palette\n\n\ntype Button msg\n    = Button (Details msg)\n\n\ntype alias Details msg =\n    { label : String\n    , style : Style\n    , size : Size\n    , widthFill : Bool\n    , corners : Corners\n    , onClick : msg\n    }\n\n\ntype Size\n    = Normal\n    | Small\n\n\ntype Corners\n    = Rounded\n    | RoundedLeft\n    | RoundedRight\n    | Sharp\n\n\ntype Style\n    = Primary\n    | Secondary\n\n\n{-| -}\nprimary :\n    { label : String\n    , onClick : msg\n    }\n    -> Button msg\nprimary options =\n    Button\n        { label = options.label\n        , onClick = options.onClick\n        , style = Primary\n        , widthFill = False\n        , corners = Rounded\n        , size = Normal\n        }\n\n\n{-| -}\nsecondary :\n    { label : String\n    , onClick : msg\n    }\n    -> Button msg\nsecondary options =\n    Button\n        { label = options.label\n        , onClick = options.onClick\n        , style = Secondary\n        , widthFill = False\n        , corners = Rounded\n        , size = Normal\n        }\n\n\n{-| -}\nwithWidthFill : Button msg -> Button msg\nwithWidthFill (Button details) =\n    Button\n        { details\n            | widthFill = True\n        }\n\n\n{-| -}\nwithSmall : Button msg -> Button msg\nwithSmall (Button details) =\n    Button\n        { details\n            | size = Small\n        }\n\n\n{-| -}\nwithSecondary : Button msg -> Button msg\nwithSecondary (Button details) =\n    Button\n        { details\n            | size = Secondary\n        }\n\n\n{-| -}\nview : Button msg -> Ui.Element msg\nview (Button details) =\n    Ui.el\n        [ Ui.onClick details.onClick\n        , Ui.Theme.font.default\n\n        -- Variable styles\n        , if details.widthFill then\n            Ui.width Ui.fill\n\n          else\n            Ui.noAttr\n        , case details.size of\n            Small ->\n                Ui.Theme.padding.sm\n\n            Normal ->\n                Ui.Theme.padding.md\n        , case details.style of\n            Primary ->\n                Ui.Theme.Palette.primary\n\n            Secondary ->\n                Ui.Theme.Palette.secondary\n        , case details.corners of\n            Rounded ->\n                Ui.rounded 4\n\n            RoundedLeft ->\n                Ui.roundedWith\n                    { topLeft = 0\n                    , topRight = 4\n                    , bottomLeft = 0\n                    , bottomRight = 4\n                    }\n\n            RoundedRight ->\n                Ui.roundedWith\n                    { topLeft = 4\n                    , topRight = 0\n                    , bottomLeft = 4\n                    , bottomRight = 0\n                    }\n\n            Sharp ->\n                Ui.noAttr\n        ]\n        (Ui.text details.label)\n\n\n{-| -}\nrow : List (Ui.Attribute msg) -> List (Button msg) -> Ui.Element msg\nrow attrs buttons =\n    let\n        buttonCount =\n            List.length buttons\n    in\n    Ui.row attrs\n        (List.indexedMap\n            (\\index (Button details) ->\n                Button\n                    { details\n                        | corners =\n                            if index == 0 then\n                                RoundedRight\n\n                            else if index == buttonCount - 1 then\n                                RoundedLeft\n\n                            else\n                                Sharp\n                    }\n                    |> view\n            )\n            buttons\n        )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Divider.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Divider.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Divider exposing (horizontal, vertical)\n\n{-| -}\n\nimport Ui\nimport Ui.Theme\nimport Ui.Theme.Palette\n\n\n{-| -}\nhorizontal : Ui.Element msg\nhorizontal =\n    Ui.el\n        [ Ui.height (Ui.px 1)\n        , Ui.width Ui.fill\n        , Ui.Theme.Palette.neutralInverted\n        ]\n        Ui.none\n\n\n{-| -}\nvertical : Ui.Element msg\nvertical =\n    Ui.el\n        [ Ui.width (Ui.px 1)\n        , Ui.height Ui.fill\n        , Ui.Theme.Palette.neutralInverted\n        ]\n        Ui.none\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Dropdown.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Dropdown.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Dropdown exposing (Visible, init, withMenu)\n\n{-| This is for attaching a dropdown menu\n-}\n\nimport Ui\nimport WebComponent.Portal\n\n\ninit : Visible\ninit =\n    Visible WebComponent.Portal.closed\n\n\ntype Visible\n    = Visible WebComponent.Portal.Model\n\n\nwithMenu :\n    { open : Visible\n    , onOpen : Visible -> msg\n    , menu : Ui.Element msg\n    }\n    -> Ui.Element msg\n    -> Ui.Element msg\nwithMenu options root =\n    Ui.html <|\n        WebComponent.Portal.view\n            { position = WebComponent.Portal.ToRightOf\n            , model =\n                case options.open of\n                    Visible portal ->\n                        portal\n            , onMsg = options.onOpen << Visible\n            , button = Ui.embed [] root\n            , menu = Ui.embed [] options.menu\n            }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Editor.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Editor.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Editor exposing\n    ( Control, bold, bulleted, control, h1, h2, h3, italic, code, numbered, paragraph\n    , ControlBar, controls, noControls\n    , fromMarkdown\n    , update, Msg, Model\n    , Event\n    , view\n    , toMarkdown\n    , Style, StyleDetails, style, class\n    )\n\n{-|\n\n@docs Control, bold, bulleted, control, h1, h2, h3, italic, code, numbered, paragraph\n\n@docs ControlBar, controls, noControls\n\n@docs fromMarkdown\n\n@docs update, Msg, Model\n\n@docs Event\n\n@docs view\n\n@docs toMarkdown\n\n\n# Styling\n\n@docs Style, StyleDetails, style, class\n\n-}\n\nimport Dict\nimport Html\nimport Html.Attributes as Attr\nimport Html.Events as Event\nimport Json.Decode as Decode\nimport Json.Encode as Encode\nimport Markdown.Block as Block\nimport Markdown.Parser\n\n\ncolumn attrs children =\n    Html.div attrs children\n\n\nrow attrs children =\n    Html.div attrs children\n\n\nnone =\n    Html.text \"\"\n\n\nborder =\n    -- Ui.Theme.border.small\n    Attr.style \"border\" \"1px solid #e2e8f0\"\n\n\nborderRadius =\n    -- Ui.Theme.borderRadius.medium\n    Attr.style \"border-radius\" \"4px\"\n\n\ntype alias Element msg =\n    Html.Html msg\n\n\nh1 : List (Html.Attribute msg) -> Element msg -> Control msg\nh1 =\n    control (Heading 1)\n\n\nh2 : List (Html.Attribute msg) -> Element msg -> Control msg\nh2 =\n    control (Heading 2)\n\n\nh3 : List (Html.Attribute msg) -> Element msg -> Control msg\nh3 =\n    control (Heading 3)\n\n\nparagraph : List (Html.Attribute msg) -> Element msg -> Control msg\nparagraph =\n    control Paragraph\n\n\nbold : List (Html.Attribute msg) -> Element msg -> Control msg\nbold =\n    control Bold\n\n\ncode : List (Html.Attribute msg) -> Element msg -> Control msg\ncode =\n    control Code\n\n\ncodeBlock : List (Html.Attribute msg) -> Element msg -> Control msg\ncodeBlock =\n    control CodeBlock\n\n\nitalic : List (Html.Attribute msg) -> Element msg -> Control msg\nitalic =\n    control Italic\n\n\nbulleted : List (Html.Attribute msg) -> Element msg -> Control msg\nbulleted =\n    control Bulleted\n\n\nnumbered : List (Html.Attribute msg) -> Element msg -> Control msg\nnumbered =\n    control Numbered\n\n\nstyle :\n    { header : StyleDetails -> Style\n    , paragraph : StyleDetails -> Style\n    , bold : StyleDetails -> Style\n    , italic : StyleDetails -> Style\n    , code : StyleDetails -> Style\n    , bulleted : StyleDetails -> Style\n    , numbered : StyleDetails -> Style\n    }\nstyle =\n    { header = Style (Heading 1)\n    , paragraph = Style Paragraph\n    , bold = Style Bold\n    , italic = Style Italic\n    , code = Style Code\n    , bulleted = Style Bulleted\n    , numbered = Style Numbered\n    }\n\n\nclass : String -> StyleDetails\nclass className =\n    { class = className\n    , style = []\n    }\n\n\ntype Style\n    = Style TipTapCommand StyleDetails\n\n\ntype alias StyleDetails =\n    { class : String\n    , style : List ( String, String )\n    }\n\n\ntype TipTapCommand\n    = Heading Int\n    | Paragraph\n    | Bold\n    | Italic\n    | Code\n    | CodeBlock\n    | Bulleted\n    | Numbered\n\n\ntype ControlBar msg\n    = ControlBar\n        { elem : List (Html.Attribute msg) -> List (Html.Html msg) -> Html.Html msg\n        , attrs : List (Html.Attribute msg)\n        , controls : List (Control msg)\n        }\n\n\nnoControls : ControlBar msg\nnoControls =\n    ControlBar { attrs = [], controls = [] }\n\n\ncontrols :\n    (List (Html.Attribute msg) -> List (Html.Html msg) -> Html.Html msg)\n    -> List (Html.Attribute msg)\n    -> List (Control msg)\n    -> ControlBar msg\ncontrols elem attrs children =\n    ControlBar\n        { elem = elem\n        , attrs = attrs\n        , controls = children\n        }\n\n\ntype Control msg\n    = Control\n        { command : TipTapCommand\n        , attrs : List (Html.Attribute msg)\n        , children : Element msg\n        }\n\n\ncontrol :\n    TipTapCommand\n    -> List (Html.Attribute msg)\n    -> Element msg\n    -> Control msg\ncontrol command attrs element =\n    Control\n        { command = command\n        , attrs = toAttr command :: attrs\n        , children = element\n        }\n\n\ntoAttr : TipTapCommand -> Html.Attribute msg\ntoAttr command =\n    -- Ui.htmlAttribute <|\n    case command of\n        Heading level ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-heading\" )\n                    , ( \"heading\", Encode.int level )\n                    ]\n                )\n\n        Paragraph ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-paragraph\" )\n                    ]\n                )\n\n        Bold ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-bold\" )\n                    ]\n                )\n\n        Italic ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-italic\" )\n                    ]\n                )\n\n        Code ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-code\" )\n                    ]\n                )\n\n        CodeBlock ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-codeblock\" )\n                    ]\n                )\n\n        Bulleted ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-bullet-list\" )\n                    ]\n                )\n\n        Numbered ->\n            Attr.property \"editorControl\"\n                (Encode.object\n                    [ ( \"cmd\", Encode.string \"toggle-numbered-list\" )\n                    ]\n                )\n\n\nfromMarkdown : String -> Model\nfromMarkdown markdown =\n    Model\n        { initial = markdown\n        , updated = Nothing\n        }\n\n\ntype Msg\n    = ContentUpdated State\n\n\nupdate : Msg -> Model -> Model\nupdate msg (Model details) =\n    case msg of\n        ContentUpdated state ->\n            Model { details | updated = Just state }\n\n\ntype Model\n    = Model ModelDetails\n\n\ntype alias ModelDetails =\n    { initial : String\n    , updated : Maybe State\n    }\n\n\n{-| All the events that can happen in the tiptap editor:\n\n<https://tiptap.dev/docs/editor/api/events>\n\n-}\ntype Event\n    = Focus\n    | Blur\n    | SelectionUpdate\n    | Destroy\n\n\n{-| -}\ntype State\n    = State Encode.Value\n\n\n{-| -}\ntoMarkdown : Model -> String\ntoMarkdown (Model model) =\n    case model.updated of\n        Just (State state) ->\n            case Decode.decodeValue decodeContent state of\n                Ok node ->\n                    nodeToMarkdown node\n\n                Err _ ->\n                    model.initial\n\n        Nothing ->\n            model.initial\n\n\ntype alias Content =\n    String\n\n\nview :\n    (List (Html.Attribute msg) -> List (Html.Html msg) -> Html.Html msg)\n    -> List (Html.Attribute msg)\n    ->\n        { text : Model\n        , controls :\n            { top : ControlBar msg\n            , bottom : ControlBar msg\n            , onSelection : ControlBar msg\n            }\n        , styles : List Style\n        , editable : Bool\n        , onEvent : Event -> Maybe msg\n        , onUpdate : Msg -> msg\n        }\n    -> Element msg\nview layout attrs model =\n    layout\n        (Attr.class \"tiptap-editor-container\" :: attrs)\n        [ viewControlBar model.controls.top\n        , Html.node \"tiptap-editor\"\n            ([ Attr.property \"content\" (encodeModel model.text)\n             , Attr.property \"editable\" (Encode.bool model.editable)\n             , Attr.property \"elementStyles\" (Encode.dict identity encodeStyle (toStyleDict model.styles))\n             ]\n                ++ toEventHandlers model.onEvent model.onUpdate\n            )\n            []\n        , viewControlBar model.controls.bottom\n        ]\n\n\ntoStyleDict : List Style -> Dict.Dict String Style\ntoStyleDict styles =\n    List.foldl\n        (\\((Style command details) as fullStyle) acc ->\n            Dict.insert (commandToString command) fullStyle acc\n        )\n        Dict.empty\n        styles\n\n\nencodeStyle : Style -> Encode.Value\nencodeStyle (Style command details) =\n    Encode.object\n        [ ( \"command\", Encode.string (commandToString command) )\n        , ( \"class\", Encode.string details.class )\n        , ( \"style\", Encode.string (List.foldl renderStyles \"\" details.style) )\n        ]\n\n\nrenderStyles : ( String, String ) -> String -> String\nrenderStyles ( key, value ) acc =\n    key ++ \":\" ++ value ++ \";\" ++ acc\n\n\ncommandToString : TipTapCommand -> String\ncommandToString command =\n    case command of\n        Heading _ ->\n            \"heading\"\n\n        Paragraph ->\n            \"paragraph\"\n\n        Bold ->\n            \"bold\"\n\n        Italic ->\n            \"italic\"\n\n        Code ->\n            \"code\"\n\n        CodeBlock ->\n            \"codeBlock\"\n\n        Bulleted ->\n            \"bulletList\"\n\n        Numbered ->\n            \"orderedList\"\n\n\nencodeModel : Model -> Encode.Value\nencodeModel (Model details) =\n    encodeMarkdown details.initial\n\n\nviewControlBar : ControlBar msg -> Element msg\nviewControlBar (ControlBar bar) =\n    if List.isEmpty bar.controls && List.isEmpty bar.attrs then\n        none\n\n    else\n        bar.elem bar.attrs\n            (List.map\n                (\\(Control ctrl) ->\n                    Html.node \"tiptap-control\" ctrl.attrs [ ctrl.children ]\n                )\n                bar.controls\n            )\n\n\ntoEventHandlers : (Event -> Maybe msg) -> (Msg -> msg) -> List (Html.Attribute msg)\ntoEventHandlers onEvent onUpdate =\n    let\n        on eventName decoder =\n            Event.on eventName\n                (decoder\n                    |> Decode.andThen\n                        (\\event ->\n                            case onEvent event of\n                                Just msg ->\n                                    Decode.succeed msg\n\n                                Nothing ->\n                                    Decode.fail \"Not listening to this event.\"\n                        )\n                )\n    in\n    [ on \"editor-focused\" (Decode.succeed Focus)\n    , on \"editor-blurred\" (Decode.succeed Blur)\n    , Event.on \"editor-updated\" (Decode.map (onUpdate << ContentUpdated) decodeState)\n    , on \"editor-selection-updated\" (Decode.succeed SelectionUpdate)\n    , on \"destroy\" (Decode.succeed Destroy)\n    ]\n\n\ndecodeState : Decode.Decoder State\ndecodeState =\n    Decode.field \"json\" Decode.value\n        |> Decode.map State\n\n\ndecodeContent : Decode.Decoder Node\ndecodeContent =\n    Decode.field \"detail\" decodeNode\n\n\n{-|\n\n    Values\n\n        type: String (paragraph, heading, text, doc)\n        attrs: List Attr\n        marks: List Mark\n\n        -- one or the other\n        content: List Node\n        text: String\n\n\n    Mark: a list of styles.  Curious if these are always a type: value pair, because this could be a set instead of a list\n        [{type: bold}, {type: italic}]\n\n-}\ndecodeNode : Decode.Decoder Node\ndecodeNode =\n    Decode.field \"type\" Decode.string\n        |> Decode.andThen\n            (\\tipe ->\n                case tipe of\n                    \"text\" ->\n                        Decode.map Text <|\n                            Decode.map2 TextDetails\n                                (Decode.field \"text\" Decode.string)\n                                (Decode.field \"marks\" (Decode.list decodeMark)\n                                    |> Decode.maybe\n                                    |> Decode.map (Maybe.withDefault [])\n                                )\n\n                    _ ->\n                        Decode.map Node <|\n                            Decode.map2 (NodeDetails tipe)\n                                (Decode.field \"attrs\" (Decode.dict decodeValue)\n                                    |> Decode.maybe\n                                    |> Decode.map (Maybe.withDefault Dict.empty)\n                                )\n                                (Decode.field \"content\" (Decode.list (Decode.lazy (\\_ -> decodeNode))))\n            )\n\n\ndecodeMark : Decode.Decoder Mark\ndecodeMark =\n    Decode.field \"type\" Decode.string\n        |> Decode.map Mark\n\n\ndecodeValue : Decode.Decoder Val\ndecodeValue =\n    Decode.oneOf\n        [ Decode.map Str Decode.string\n        , Decode.map Integer Decode.int\n        ]\n\n\ntype Node\n    = Node NodeDetails\n    | Text TextDetails\n\n\ntype alias TextDetails =\n    { text : String\n    , marks : List Mark\n    }\n\n\ntype alias Mark =\n    { type_ : String\n    }\n\n\ntype alias NodeDetails =\n    { type_ : String\n    , attrs : Dict.Dict String Val\n    , content : List Node\n    }\n\n\ntype Val\n    = Str String\n    | Integer Int\n\n\nencodeMarkdown : String -> Encode.Value\nencodeMarkdown markdown =\n    case Markdown.Parser.parse markdown of\n        Err err ->\n            Encode.string markdown\n\n        Ok blockList ->\n            Encode.object\n                [ ( \"type\", Encode.string \"doc\" )\n                , ( \"content\", Encode.list encodeBlock blockList )\n                ]\n\n\nencodeBlock : Block.Block -> Encode.Value\nencodeBlock block =\n    case block of\n        Block.Heading headingLevel content ->\n            Encode.object\n                [ ( \"type\", Encode.string \"heading\" )\n                , ( \"attrs\", Encode.object [ ( \"level\", Encode.int (Block.headingLevelToInt headingLevel) ) ] )\n                , ( \"content\", Encode.list identity (List.concatMap encodeInline content) )\n                ]\n\n        Block.Paragraph inlines ->\n            Encode.object\n                [ ( \"type\", Encode.string \"paragraph\" )\n                , ( \"content\", Encode.list identity (List.concatMap encodeInline inlines) )\n                ]\n\n        Block.HtmlBlock html ->\n            Encode.string \"\"\n\n        Block.UnorderedList tight items ->\n            Encode.object\n                [ ( \"type\", Encode.string \"bulletList\" )\n                , ( \"content\"\n                  , Encode.list\n                        (\\(Block.ListItem task childrenBlocks) ->\n                            Encode.object\n                                [ ( \"type\", Encode.string \"listItem\" )\n                                , ( \"content\"\n                                  , Encode.list encodeBlock childrenBlocks\n                                  )\n                                ]\n                        )\n                        items\n                  )\n                ]\n\n        Block.OrderedList tight startingIndex listListItems ->\n            Encode.object\n                [ ( \"type\", Encode.string \"orderedList\" )\n                , ( \"attrs\", Encode.object [ ( \"start\", Encode.int startingIndex ) ] )\n                , ( \"content\"\n                  , Encode.list\n                        (\\childrenBlocks ->\n                            Encode.object\n                                [ ( \"type\", Encode.string \"listItem\" )\n                                , ( \"content\"\n                                  , Encode.list encodeBlock childrenBlocks\n                                  )\n                                ]\n                        )\n                        listListItems\n                  )\n                ]\n\n        Block.CodeBlock { body, language } ->\n            Encode.object\n                [ ( \"type\", Encode.string \"codeBlock\" )\n                , ( \"content\", encodeText [] body )\n                ]\n\n        Block.ThematicBreak ->\n            Encode.string \"\"\n\n        Block.BlockQuote nestedBlocks ->\n            Encode.string \"\"\n\n        Block.Table headers rows ->\n            Encode.string \"\"\n\n\nencodeMark : Mark -> Encode.Value\nencodeMark mark =\n    Encode.object\n        [ ( \"type\", Encode.string mark.type_ ) ]\n\n\nencodeInline : Block.Inline -> List Encode.Value\nencodeInline inline =\n    encodeInlineHelper [] inline\n\n\nencodeInlineHelper : List Mark -> Block.Inline -> List Encode.Value\nencodeInlineHelper marks inline =\n    case inline of\n        Block.Strong inner ->\n            List.concatMap (encodeInlineHelper ({ type_ = \"bold\" } :: marks)) inner\n\n        Block.Emphasis inner ->\n            List.concatMap (encodeInlineHelper ({ type_ = \"italic\" } :: marks)) inner\n\n        Block.Strikethrough inner ->\n            List.concatMap (encodeInlineHelper ({ type_ = \"strike\" } :: marks)) inner\n\n        Block.Image src title children ->\n            []\n\n        Block.Text string ->\n            [ encodeText marks string ]\n\n        Block.CodeSpan string ->\n            [ encodeText ({ type_ = \"code\" } :: marks) string ]\n\n        Block.Link destination title inlines ->\n            []\n\n        Block.HardLineBreak ->\n            []\n\n        Block.HtmlInline html ->\n            []\n\n\nencodeText : List Mark -> String -> Encode.Value\nencodeText marks text =\n    case marks of\n        [] ->\n            Encode.object\n                [ ( \"type\", Encode.string \"text\" )\n                , ( \"text\", Encode.string text )\n                ]\n\n        _ ->\n            Encode.object\n                [ ( \"type\", Encode.string \"text\" )\n                , ( \"text\", Encode.string text )\n                , ( \"marks\", Encode.list encodeMark marks )\n                ]\n\n\nnodeToMarkdown : Node -> String\nnodeToMarkdown node =\n    case node of\n        Text details ->\n            case details.marks of\n                [] ->\n                    details.text\n\n                _ ->\n                    wrapMark details.marks details.text\n\n        Node details ->\n            let\n                content =\n                    List.map nodeToMarkdown details.content\n                        |> String.join \"\"\n            in\n            case details.type_ of\n                \"paragraph\" ->\n                    content ++ \"\\n\"\n\n                \"heading\" ->\n                    case Dict.get \"level\" details.attrs of\n                        Just (Integer level) ->\n                            String.repeat level \"#\" ++ \" \" ++ content ++ \"\\n\"\n\n                        _ ->\n                            content\n\n                \"text\" ->\n                    content\n\n                _ ->\n                    content\n\n\nwrapMark : List Mark -> String -> String\nwrapMark marks text =\n    List.foldl\n        (\\mark txt ->\n            case mark.type_ of\n                \"bold\" ->\n                    \"**\" ++ txt ++ \"**\"\n\n                \"italic\" ->\n                    \"*\" ++ txt ++ \"*\"\n\n                \"strike\" ->\n                    \"~\" ++ txt ++ \"~\"\n\n                \"code\" ->\n                    \"`\" ++ txt ++ \"`\"\n\n                _ ->\n                    txt\n        )\n        text\n        marks\n\n\ngetInt : String -> List ( String, String ) -> Maybe Int\ngetInt key attrs =\n    case List.filter (\\( k, _ ) -> k == key) attrs of\n        [ ( _, value ) ] ->\n            String.toInt value\n\n        _ ->\n            Nothing\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Markdown.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Markdown.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Markdown exposing (parse, render, view)\n\nimport Html exposing (Html)\nimport Html.Attributes\nimport Http\nimport Markdown.Block as Block\nimport Markdown.Parser\nimport Markdown.Renderer\nimport Theme.Color as Color\nimport Theme.Layout as Layout\nimport Theme.Text as Text\nimport Ui\nimport Ui.Divider\nimport Ui.Font\nimport Ui.Prose\nimport Ui.Table\n\n\nview : String -> Ui.Element msg\nview src =\n    case parse src of\n        Ok blocks ->\n            Layout.column.sm []\n                (List.map render blocks)\n\n        Err errors ->\n            Ui.text src\n\n\nparse : String -> Result (List String) (List Block.Block)\nparse src =\n    Markdown.Parser.parse src\n        |> Result.mapError (List.map Markdown.Parser.deadEndToString)\n\n\nrender : Block.Block -> Ui.Element msg\nrender block =\n    case block of\n        Block.Heading Block.H1 content ->\n            Text.h1\n                (Block.extractInlineText content)\n\n        Block.Heading Block.H2 content ->\n            Text.h2\n                (Block.extractInlineText content)\n\n        Block.Heading _ content ->\n            Text.h2\n                (Block.extractInlineText content)\n\n        Block.Paragraph inlines ->\n            paragraph []\n                (List.map renderInline inlines)\n\n        Block.HtmlBlock html ->\n            Ui.none\n\n        Block.UnorderedList tight items ->\n            Layout.column.sm []\n                (List.map\n                    (\\(Block.ListItem checked innerBlocks) ->\n                        Layout.row.sm []\n                            [ Ui.text \"•\"\n                            , paragraph [] (List.map render innerBlocks)\n                            ]\n                    )\n                    items\n                )\n\n        Block.OrderedList tight startingIndex items ->\n            Layout.column.sm []\n                (List.indexedMap\n                    (\\index innerBlocks ->\n                        Layout.row.sm []\n                            [ Ui.text (String.fromInt (startingIndex + index))\n                            , paragraph [] (List.map render innerBlocks)\n                            ]\n                    )\n                    items\n                )\n\n        Block.CodeBlock codeBlock ->\n            Ui.el\n                [ Layout.padding.sm3\n                , Ui.background Color.grey100\n                , Ui.rounded 4\n                ]\n                (Ui.text codeBlock.code)\n\n        Block.ThematicBreak ->\n            Ui.Divider.horizontal\n\n        Block.BlockQuote nestedBlocks ->\n            paragraph [ Layout.padding.lg ]\n                (List.map render nestedBlocks)\n\n        Block.Table headers rows ->\n            let\n                columns =\n                    Ui.Table.columns\n                        (List.indexedMap\n                            (\\index cell ->\n                                let\n                                    isNumeric =\n                                        rows\n                                            |> List.take 3\n                                            |> List.any\n                                                (isNumericText << Block.extractInlineText << getIndex index)\n                                in\n                                Ui.Table.column\n                                    { header =\n                                        header\n                                            [ if isNumeric then\n                                                Ui.alignRight\n\n                                              else\n                                                Ui.noAttr\n                                            ]\n                                            (Block.extractInlineText cell.label)\n                                    , view =\n                                        \\row ->\n                                            let\n                                                inlines =\n                                                    getIndex index row\n                                            in\n                                            inlines\n                                                |> List.map renderInline\n                                                |> paragraph\n                                                    [ if isNumeric then\n                                                        Ui.alignRight\n\n                                                      else\n                                                        Ui.width Ui.fill\n                                                    ]\n                                                |> Ui.el [ Ui.width Ui.fill ]\n                                                |> Ui.Table.cell\n                                                    [ if index == 0 then\n                                                        Ui.width (Ui.px 10)\n\n                                                      else\n                                                        Ui.noAttr\n                                                    ]\n                                    }\n                                    |> Ui.Table.withWidth\n                                        { fill = index /= 0\n                                        , min = Nothing\n                                        , max = Nothing\n                                        }\n                            )\n                            headers\n                        )\n            in\n            Ui.Table.view [ Ui.width Ui.fill ] columns rows\n\n\nrenderInline : Block.Inline -> Ui.Element msg\nrenderInline inline =\n    case inline of\n        Block.Strong innerInlines ->\n            paragraph [ Ui.Font.weight Ui.Font.bold ]\n                (List.map renderInline innerInlines)\n\n        Block.Emphasis innerInlines ->\n            paragraph [ Ui.Font.italic ]\n                (List.map renderInline innerInlines)\n\n        Block.Strikethrough innerInlines ->\n            paragraph [ Ui.Font.strike ]\n                (List.map renderInline innerInlines)\n\n        Block.Image src title children ->\n            Ui.none\n\n        Block.Text string ->\n            Ui.text string\n\n        Block.CodeSpan string ->\n            Ui.el\n                [ Layout.padding.sm4\n                , Ui.background Color.grey100\n                , Ui.rounded 4\n                ]\n                (Ui.text string)\n\n        Block.Link destination title inlines ->\n            Ui.el [ Ui.link destination ]\n                (Ui.text (Block.extractInlineText inlines))\n\n        Block.HardLineBreak ->\n            Ui.el [ Ui.Font.exactWhitespace ]\n                (Ui.html (Html.text \"\\n\"))\n\n        Block.HtmlInline html ->\n            Ui.none\n\n\nisNumericText : String -> Bool\nisNumericText str =\n    String.any Char.isDigit str\n\n\ngetIndex : Int -> List (List thing) -> List thing\ngetIndex index items =\n    case items of\n        [] ->\n            []\n\n        first :: remaining ->\n            if index <= 0 then\n                first\n\n            else\n                getIndex (index - 1) remaining\n\n\nheader attrs content =\n    Ui.Table.cell\n        [ Ui.borderColor (Ui.rgb 200 200 200)\n        , Ui.borderWith\n            { top = 0\n            , left = 0\n            , right = 0\n            , bottom = 1\n            }\n        , Ui.paddingWith\n            { top = 16\n            , left = 16\n            , right = 16\n            , bottom = 8\n            }\n        , Ui.height Ui.fill\n        ]\n        (Ui.el [ Ui.width Ui.fill ]\n            (Ui.el attrs (Ui.text content))\n        )\n\n\nparagraph attrs =\n    Ui.Prose.paragraph (Ui.Font.lineHeight 1.4 :: attrs)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Modal.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Modal.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Modal exposing\n    ( Modal, modal\n    , withCloseOnBackdropClick\n    , view\n    )\n\n{-|\n\n@docs Modal, modal\n\n@docs withCloseOnBackdropClick\n\n@docs view\n\n-}\n\nimport Ui\nimport Ui.Input\nimport Ui.Theme\n\n\ntype Modal msg\n    = Modal (Details msg)\n\n\ntype alias Details msg =\n    { visible : Bool\n    , closeOnClickBackdrop : Maybe (Bool -> msg)\n    , content : Ui.Element msg\n    }\n\n\n{-| -}\nmodal :\n    { visible : Bool\n    , content : Ui.Element msg\n    }\n    -> Switch msg\nmodal options =\n    Modal\n        { visible = options.visible\n        , content = options.content\n        , closeOnClickBackdrop = Nothing\n        }\n\n\nwithCloseOnBackdropClick : (Bool -> msg) -> Modal msg -> Modal msg\nwithCloseOnBackdropClick closeOnClickBackdrop (Modal details) =\n    Modal\n        { details\n            | closeOnClickBackdrop = Just closeOnClickBackdrop\n        }\n\n\n{-| -}\nview : Modal msg -> Ui.Element msg\nview (Modal options) =\n    Ui.el\n        [ Ui.width Ui.fill\n        , Ui.height Ui.fill\n        , Ui.Theme.background.backdrop\n        , case options.closeOnClickBackdrop of\n            Nothing ->\n                Ui.noAttr\n\n            Just msg ->\n                -- TODO: Ui.clickOnThisElement?\n                Ui.onClick msg\n        ]\n        (Ui.el\n            [ Ui.width (Ui.px 800)\n            , Ui.height (Ui.px 600)\n            , Ui.centerX\n            , Ui.centerY\n            ]\n            options.content\n        )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Switch.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Switch.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Switch exposing\n    ( Switch, switch\n    , view\n    )\n\n{-|\n\n@docs Switch, switch\n\n@docs view\n\n-}\n\nimport Ui\nimport Ui.Input\nimport Ui.Theme\nimport Ui.Theme.Palette\n\n\ntype Switch msg\n    = Switch (Details msg)\n\n\ntype alias Details msg =\n    { label : String\n    , value : Bool\n    , onToggle : Bool -> msg\n    }\n\n\n{-| -}\nswitch :\n    { onToggle : Bool -> msg\n    , value : Bool\n    }\n    -> Switch msg\nswitch options =\n    Switch\n        { label = Nothing\n        , value = options.value\n        , onToggle = options.onToggle\n        }\n\n\n{-| -}\nview : Switch msg -> Ui.Element msg\nview (Switch options) =\n    Ui.Input.checkbox []\n        { onChange = options.onToggle\n        , icon = Just (viewToggle options)\n        , checked = options.value\n        , label =\n            Ui.Input.labelRight []\n                (Ui.text optinos.label)\n        }\n\n\nviewToggle : Details msg -> Bool -> Ui.Element msg\nviewToggle details on =\n    Ui.el\n        (List.concat\n            [ [ Ui.width (Ui.px 36)\n              , Ui.height (Ui.px 16)\n              , Ui.circle\n              , Ui.Theme.padding.sm4\n\n              --   , Ui.disabledIf config.isDisabled\n              --   , Ui.Transition.create\n              --         [ Ui.Transition.FontColor\n              --         , Ui.Transition.BackgroundColor\n              --         ]\n              ]\n            , -- if config.isDisabled then\n              --     if on then\n              --         [ Ui.backgroundColor.primaryHighlight\n              --         , Ui.fontColor.greyscale600\n              --         ]\n              --     else\n              --         [ Ui.backgroundColor.greyscale200\n              --         , Ui.fontColor.greyscale500\n              --         ]\n              --   else\n              if on then\n                -- [ Ui.backgroundColor.primary\n                -- , Ui.fontColor.greyscale0\n                -- , Ui.hover.backgroundColor.primaryHover\n                -- , Ui.active.backgroundColor.primaryActive\n                -- ]\n                Ui.Theme.Palette.primary\n\n              else\n                -- [ Ui.backgroundColor.greyscale300\n                -- , Ui.fontColor.greyscale800\n                -- , Ui.hover.backgroundColor.greyscale400\n                -- , Ui.active.backgroundColor.greyscale500\n                -- ]\n                Ui.Theme.Palette.inactive\n            ]\n        )\n        (Ui.el\n            [ Ui.Theme.Palette.secondary\n\n            -- , Ui.Theme.border.small\n            , Ui.width (Ui.px 20)\n            , Ui.height (Ui.px 20)\n            , Ui.circle\n            , Ui.move\n                (if config.value then\n                    Ui.right 16\n\n                 else\n                    Ui.right 0\n                )\n\n            -- , Ui.Transition.create [ Ui.Transition.Transform ]\n            ]\n            Ui.none\n        )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Ui/Tooltip.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Ui/Tooltip.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Ui.Tooltip exposing (..)\n\n{-| -}\n\nimport Ui\nimport Ui.Theme\nimport Ui.Theme.Palette\nimport WebComponents.Portal as Portal\n\n\n{-| -}\ntooltip : String -> Ui.Attribute msg\ntooltip label =\n    Ui.above\n        (Ui.el [ Ui.Theme.Palette.neutralInverted ]\n            (Ui.text label)\n        )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }
}
