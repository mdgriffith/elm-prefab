
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";


export const Page_Guide = {
   moduleName: "Page.Guide",
   path: "/Page/Guide.elm",
   contents: "module Page.Guide exposing (page, Model, Msg)\n\n{-|\n\n@docs page, Model, Msg\n\n-}\n\nimport App.Page\nimport App.Page.Id\nimport App.Resources\nimport App.View\nimport App.View.Id\nimport Effect exposing (Effect)\nimport Html exposing (Html)\nimport Listen exposing (Listen)\nimport Ui\nimport Ui.Attr\n\n\n{-| -}\ntype alias Model =\n    { guide : Maybe { path : String, content : String } }\n\n\n{-| -}\ntype Msg\n    = ReplaceMe\n\n\npage : App.Page.Page App.Resources.Resources App.Page.Id.Guide_Params Msg Model\npage =\n    App.Page.page\n        { init = init\n        , update = update\n        , subscriptions = subscriptions\n        , view = view\n        }\n\n\ninit : App.Page.Id.Id -> App.Page.Id.Guide_Params -> App.Resources.Resources -> Maybe Model -> App.Page.Init Msg Model\ninit pageId params shared maybeCached =\n    App.Page.init { guide = lookupGuide (String.join \"/\" params.path_) }\n\n\nlookupGuide : String -> Maybe { path : String, content : String }\nlookupGuide path =\n    List.head (List.filter (\\guide -> guide.path == path) guides)\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, Effect Msg )\nupdate shared msg model =\n    ( model, Effect.none )\n\n\nsubscriptions : App.Resources.Resources -> Model -> Listen Msg\nsubscriptions shared model =\n    Listen.none\n\n\nview : App.View.Id.Id -> App.Resources.Resources -> Model -> App.View.View Msg\nview viewId shared model =\n    { title = \"Guides\"\n    , body =\n        case model.guide of\n            Just guide ->\n                Ui.Markdown.view guide.content\n                    |> Ui.el\n                        [ Ui.pad 48\n                        , Ui.Attr.width 800\n                        ]\n\n            Nothing ->\n                Html.text \"Guide not found\"\n    }\n"
}

export const Page_Home = {
   moduleName: "Page.Home",
   path: "/Page/Home.elm",
   contents: "module Page.Home exposing (page, Model, Msg)\n\n{-|\n\n@docs page, Model, Msg\n\n-}\n\nimport App.Page\nimport App.Page.Id\nimport App.Resources\nimport App.Route\nimport App.View\nimport App.View.Id\nimport Docs.Packages\nimport Effect exposing (Effect)\nimport Html\nimport Html.Attributes as Attr\nimport Listen exposing (Listen)\n\n\n{-| -}\ntype alias Model =\n    {}\n\n\n{-| -}\ntype Msg\n    = ReplaceMe\n\n\npage : App.Page.Page App.Resources.Resources App.Page.Id.Home_Params Msg Model\npage =\n    App.Page.page\n        { init = init\n        , update = update\n        , subscriptions = subscriptions\n        , view = view\n        }\n\n\ninit : App.Page.Id.Id -> App.Page.Id.Home_Params -> App.Resources.Resources -> Maybe Model -> App.Page.Init Msg Model\ninit pageId params shared maybeCached =\n    App.Page.init {}\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, Effect Msg )\nupdate shared msg model =\n    ( model, Effect.none )\n\n\nsubscriptions : App.Resources.Resources -> Model -> Listen Msg\nsubscriptions shared model =\n    Listen.none\n\n\nview : App.View.Id.Id -> App.Resources.Resources -> Model -> App.View.View Msg\nview viewId shared model =\n    { title = \"Directory\"\n    , body = viewPackages\n    }\n\n\nviewPackages =\n    Html.div []\n        [ Html.h1 [] [ Html.text \"Packages\" ]\n\n        ]\n"
}

export const Page_Module = {
   moduleName: "Page.Module",
   path: "/Page/Module.elm",
   contents: "module Page.Module exposing (page, Model, Msg)\n\n{-|\n\n@docs page, Model, Msg\n\n-}\n\nimport App.Page\nimport App.Page.Id\nimport App.Resources\nimport App.View\nimport App.View.Id\nimport Effect exposing (Effect)\nimport Html\nimport Listen exposing (Listen)\n\n\n{-| -}\ntype alias Model =\n    {}\n\n\n{-| -}\ntype Msg\n    = ReplaceMe\n\n\npage : App.Page.Page App.Resources.Resources App.Page.Id.Module_Params Msg Model\npage =\n    App.Page.page\n        { init = init\n        , update = update\n        , subscriptions = subscriptions\n        , view = view\n        }\n\n\ninit : App.Page.Id.Id -> App.Page.Id.Module_Params -> App.Resources.Resources -> Maybe Model -> App.Page.Init Msg Model\ninit pageId params shared maybeCached =\n    App.Page.init {}\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, Effect Msg )\nupdate shared msg model =\n    ( model, Effect.none )\n\n\nsubscriptions : App.Resources.Resources -> Model -> Listen Msg\nsubscriptions shared model =\n    Listen.none\n\n\nview : App.View.Id.Id -> App.Resources.Resources -> Model -> App.View.View Msg\nview viewId shared model =\n    { title = \"Module\"\n    , body = Html.text \"Module\"\n    }\n"
}

export const Page_Package = {
   moduleName: "Page.Package",
   path: "/Page/Package.elm",
   contents: "module Page.Package exposing (page, Model, Msg)\n\n{-|\n\n@docs page, Model, Msg\n\n-}\n\nimport App.Page\nimport App.Page.Id\nimport App.Resources\nimport App.View\nimport App.View.Id\nimport Docs.Packages\nimport Effect exposing (Effect)\nimport Elm.Docs\nimport Html exposing (Html)\nimport Html.Attributes as Attr\nimport Html.Events as Events\nimport Listen exposing (Listen)\nimport Ui\nimport Ui.Docs.Block\nimport Ui.Markdown\nimport Elm.Type\nimport Ui.Type\n\n{-| -}\ntype alias Model =\n    { name : String\n    , modules : List Elm.Docs.Module\n    , focusedModule : Maybe String\n    }\n\n\n{-| -}\ntype Msg\n    = ModuleClicked String\n\n\npage : App.Page.Page App.Resources.Resources App.Page.Id.Package_Params Msg Model\npage =\n    App.Page.page\n        { init = init\n        , update = update\n        , subscriptions = subscriptions\n        , view = view\n        }\n\n\ninit : App.Page.Id.Id -> App.Page.Id.Package_Params -> App.Resources.Resources -> Maybe Model -> App.Page.Init Msg Model\ninit pageId params shared maybeCached =\n    let\n        key =\n            String.join \"/\" params.path_\n\n        docs =\n            List.foldl\n                (\\doc found ->\n                    case found of\n                        Just d ->\n                            found\n\n                        Nothing ->\n                            if doc.name == key then\n                                Just doc\n\n                            else\n                                Nothing\n                )\n                Nothing\n                Docs.Packages.directory\n    in\n    case docs of\n        Nothing ->\n            App.Page.notFound\n\n        Just doc ->\n            App.Page.init\n                { name = doc.name\n                , modules = doc.modules\n                , focusedModule =\n                    List.head doc.modules\n                        |> Maybe.map .name\n                }\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, Effect Msg )\nupdate shared msg model =\n    case msg of\n        ModuleClicked name ->\n            ( { model | focusedModule = Just name }\n            , Effect.none\n            )\n\n\nsubscriptions : App.Resources.Resources -> Model -> Listen Msg\nsubscriptions shared model =\n    Listen.none\n\n\ngetModule : List Elm.Docs.Module -> String -> Maybe Elm.Docs.Module\ngetModule modules name =\n    List.foldl\n        (\\mod found ->\n            case found of\n                Just m ->\n                    found\n\n                Nothing ->\n                    if mod.name == name then\n                        Just mod\n\n                    else\n                        Nothing\n        )\n        Nothing\n        modules\n\n\nview : App.View.Id.Id -> App.Resources.Resources -> Model -> App.View.View Msg\nview viewId shared model =\n    { title = model.name\n    , body =\n       Ui.column\n          [ Ui.pad 48\n          , Ui.width 800\n          ]\n          [ Html.h1 [] [ Html.text model.name ]\n          , Html.div []\n              (List.map\n                  (\\mod ->\n                      Html.div\n                          [ Events.onClick (ModuleClicked mod.name)\n                          , Attr.style \"cursor\" \"pointer\"\n                          , Attr.style \"text-decoration\" \"underline\"\n                          ]\n                          [ Html.text mod.name ]\n                  )\n                  model.modules\n              )\n          , case Maybe.andThen (getModule model.modules) model.focusedModule of\n              Nothing ->\n                  Html.text \"\"\n\n              Just focusedModule ->\n                  viewModule focusedModule\n          ]\n    }\n\n\nviewModule : Elm.Docs.Module -> Html Msg\nviewModule mod =\n   Ui.column [ Ui.gap 24 ]\n        [ Html.h2 [] [ Html.text mod.name ]\n        , Ui.column\n            [ Ui.gap 24\n            ]\n            (mod\n                |> Elm.Docs.toBlocks\n                |> List.map\n                    viewBlock\n            )\n        ]\n\n\nviewBlock : Elm.Docs.Block -> Html Msg\nviewBlock block =\n    case block of\n        Elm.Docs.MarkdownBlock markdown ->\n            viewMarkdown markdown\n\n        Elm.Docs.UnionBlock details ->\n            Html.div []\n                [ viewName details.name\n                , viewMarkdown details.comment\n                ]\n\n        Elm.Docs.AliasBlock details ->\n            Html.div []\n                [ viewName details.name\n                , viewMarkdown details.comment\n                ]\n\n        Elm.Docs.ValueBlock details ->\n            Html.div []\n                [ viewTypeDefinition details\n                , viewMarkdown details.comment\n                ]\n\n        Elm.Docs.BinopBlock details ->\n            Html.div []\n                [ viewName details.name\n                , viewMarkdown details.comment\n                ]\n\n        Elm.Docs.UnknownBlock text ->\n            Html.text text\n\n\nviewName : String -> Html Msg\nviewName name =\n    Html.h2 []\n        [ Html.text name\n        ]\n\nviewTypeDefinition : {docs | name : String, tipe : Elm.Type.Type } -> Html Msg\nviewTypeDefinition details =\n    Ui.row []\n        [ Html.span [] [ Html.text (details.name  ++ \" : \")]\n        , Ui.Type.view details.tipe\n        ]\n\n\nviewMarkdown : String -> Html Msg\nviewMarkdown markdown =\n    Ui.Markdown.view markdown\n"
}

export const Ui_Docs_Block = {
   moduleName: "Ui.Docs.Block",
   path: "/Ui/Docs/Block.elm",
   contents: "module Ui.Docs.Block exposing\n    ( Info\n    , makeInfo\n    , view\n    )\n\nimport App.Route\nimport Dict\nimport Elm.Docs as Docs\nimport Elm.Type as Type\nimport Elm.Version as V\nimport Html exposing (..)\nimport Html.Attributes exposing (..)\nimport Ui.Markdown\n\n\n\n-- CONSTANTS\n\n\nmaxWidth : Int\nmaxWidth =\n    64\n\n\n\n-- VIEW\n\n\nview : Info -> Docs.Block -> Html msg\nview info block =\n    case block of\n        Docs.MarkdownBlock markdown ->\n            span [ class \"markdown-block\" ] [ Ui.Markdown.view markdown ]\n\n        Docs.ValueBlock value ->\n            viewValue info value\n\n        Docs.BinopBlock binop ->\n            viewBinop info binop\n\n        Docs.AliasBlock alias ->\n            viewAlias info alias\n\n        Docs.UnionBlock union ->\n            viewUnion info union\n\n        Docs.UnknownBlock name ->\n            span\n                [ class \"TODO-make-this-red\" ]\n                [ text \"It seems that \"\n                , code [] [ text name ]\n                , text \" does not have any docs. Please open a bug report \"\n                , a [ href \"https://github.com/elm/package.elm-lang.org/issues\" ] [ text \"here\" ]\n                , text \" with the title “UnknownBlock found in docs” and with a link to this page in the description.\"\n                ]\n\n\nviewCodeBlock : String -> String -> List (Line msg) -> Html msg\nviewCodeBlock name comment header =\n    div [ class \"docs-block\", id name ]\n        [ div [ class \"docs-header\" ] (List.map (div []) header)\n        , div [ class \"docs-comment\" ] [ Ui.Markdown.view comment ]\n        ]\n\n\n\n-- VIEW VALUE BLOCK\n\n\nviewValue : Info -> Docs.Value -> Html msg\nviewValue info { name, comment, tipe } =\n    let\n        nameHtml =\n            toBoldLink info name\n    in\n    viewCodeBlock name comment <|\n        case toLines info Other tipe of\n            One _ line ->\n                [ nameHtml :: space :: colon :: space :: line ]\n\n            More x xs ->\n                [ nameHtml, space, colon ] :: indentFour x :: List.map indentFour xs\n\n\nindentFour : Line msg -> Line msg\nindentFour =\n    (::) (text \"    \")\n\n\n\n-- VIEW BINOP BLOCK\n\n\nviewBinop : Info -> Docs.Binop -> Html msg\nviewBinop info { name, comment, tipe } =\n    let\n        nameHtml =\n            toBoldLink info (\"(\" ++ name ++ \")\")\n    in\n    viewCodeBlock name comment <|\n        case toLines info Other tipe of\n            One _ line ->\n                [ nameHtml :: space :: colon :: space :: line ]\n\n            More x xs ->\n                [ nameHtml, space, colon ] :: indentFour x :: List.map indentFour xs\n\n\n\n-- VIEW ALIAS BLOCK\n\n\nviewAlias : Info -> Docs.Alias -> Html msg\nviewAlias info { name, args, comment, tipe } =\n    let\n        varsString =\n            String.concat (List.map ((++) \" \") args)\n\n        aliasNameLine =\n            [ keyword \"type\"\n            , space\n            , keyword \"alias\"\n            , space\n            , toBoldLink info name\n            , text varsString\n            , space\n            , equals\n            ]\n    in\n    viewCodeBlock name comment <|\n        aliasNameLine\n            :: List.map indentFour (linesToList (toLines info Other tipe))\n\n\n\n-- VIEW UNION\n\n\nviewUnion : Info -> Docs.Union -> Html msg\nviewUnion info { name, comment, args, tags } =\n    let\n        varsString =\n            String.concat <| List.map ((++) \" \") args\n\n        nameLine =\n            [ keyword \"type\", space, toBoldLink info name, text varsString ]\n    in\n    viewCodeBlock name comment <|\n        case tags of\n            [] ->\n                [ nameLine ]\n\n            t :: ts ->\n                nameLine :: linesToList (toMoreLines (unionMore info) t ts)\n\n\nunionMore : Info -> MoreSettings ( String, List Type.Type ) msg\nunionMore info =\n    let\n        ctorToLines ( ctor, args ) =\n            toOneOrMore (toLines info Other (Type.Type ctor args))\n    in\n    { open = [ text \"    = \" ]\n    , sep = text \"    | \"\n    , close = Nothing\n    , openIndent = 6\n    , sepIndent = 6\n    , toLines = ctorToLines\n    }\n\n\n\n-- INFO\n\n\ntype alias Info =\n    { author : String\n    , project : String\n    , version : Maybe V.Version\n    , moduleName : String\n    , typeNameDict : TypeNameDict\n    }\n\n\ntype alias TypeNameDict =\n    Dict.Dict String ( String, String )\n\n\nmakeInfo : String -> String -> Maybe V.Version -> String -> List Docs.Module -> Info\nmakeInfo author project version moduleName docsList =\n    let\n        addUnion home union docs =\n            Dict.insert (home ++ \".\" ++ union.name) ( home, union.name ) docs\n\n        addModule docs dict =\n            List.foldl (addUnion docs.name) dict docs.unions\n    in\n    Info author project version moduleName <|\n        List.foldl addModule Dict.empty docsList\n\n\n\n-- CREATE LINKS\n\n\ntoBoldLink : Info -> String -> Html msg\ntoBoldLink info name =\n    makeLink info [ bold ] name name\n\n\nbold : Attribute msg\nbold =\n    style \"font-weight\" \"bold\"\n\n\nmakeLink : Info -> List (Attribute msg) -> String -> String -> Html msg\nmakeLink { author, project, version, moduleName } attrs tagName humanName =\n    let\n        url =\n            -- Href.toModule author project version moduleName (Just tagName)\n            App.Route.toString (App.Route.Package { path_ = [ author, project ] })\n    in\n    a (href url :: attrs) [ text humanName ]\n\n\ntoLinkLine : Info -> String -> Lines (Line msg)\ntoLinkLine info qualifiedName =\n    case Dict.get qualifiedName info.typeNameDict of\n        Nothing ->\n            let\n                shortName =\n                    last qualifiedName (String.split \".\" qualifiedName)\n            in\n            One (String.length shortName) [ span [ title qualifiedName ] [ text shortName ] ]\n\n        Just ( moduleName, name ) ->\n            One (String.length name) [ makeLink { info | moduleName = moduleName } [] name name ]\n\n\nlast : a -> List a -> a\nlast backup list =\n    case list of\n        [] ->\n            backup\n\n        x :: [] ->\n            x\n\n        _ :: xs ->\n            last backup xs\n\n\n\n-- LINES\n\n\ntype alias Line msg =\n    List (Html msg)\n\n\ntype Lines line\n    = One Int line\n    | More line (List line)\n\n\ntype Context\n    = Func\n    | App\n    | Other\n\n\ntoLines : Info -> Context -> Type.Type -> Lines (Line msg)\ntoLines info context tipe =\n    case tipe of\n        Type.Var x ->\n            One (String.length x) [ text x ]\n\n        Type.Lambda arg result ->\n            let\n                lambdaToLine =\n                    if context == Other then\n                        toLinesHelp lambdaOne lambdaMore\n\n                    else\n                        toLinesHelp lambdaOneParens lambdaMoreParens\n            in\n            lambdaToLine (toLines info Func arg) <|\n                List.map (toLines info Func) (collectArgs [] result)\n\n        Type.Tuple [] ->\n            One 2 [ text \"()\" ]\n\n        Type.Tuple (arg :: args) ->\n            toLinesHelp tupleOne\n                tupleMore\n                (toLines info Other arg)\n                (List.map (toLines info Other) args)\n\n        Type.Type name args ->\n            let\n                needsParens =\n                    context == App && not (List.isEmpty args)\n            in\n            toLinesHelp\n                (typeOne needsParens)\n                (typeMore needsParens)\n                (toLinkLine info name)\n                (List.map (toLines info App) args)\n\n        Type.Record [] Nothing ->\n            One 2 [ text \"{}\" ]\n\n        Type.Record [] (Just ext) ->\n            One (6 + String.length ext) [ text <| \"{ \" ++ ext ++ \" | }\" ]\n\n        Type.Record (f :: fs) extension ->\n            let\n                toLns ( field, fieldType ) =\n                    ( field, toLines info Other fieldType )\n            in\n            case extension of\n                Nothing ->\n                    if List.isEmpty fs then\n                        toLinesHelp recordOne recordMore (toLns f) (List.map toLns fs)\n\n                    else\n                        toMoreLines recordMore (toLns f) (List.map toLns fs)\n\n                Just ext ->\n                    case toLinesHelp (recordOneExt ext) recordMoreExt (toLns f) (List.map toLns fs) of\n                        One width line ->\n                            One width line\n\n                        More first rest ->\n                            More [ text \"{ \", text ext ] (first :: rest ++ [ [ text \"}\" ] ])\n\n\n\n-- FUNCTIONS\n\n\ncollectArgs : List Type.Type -> Type.Type -> List Type.Type\ncollectArgs revArgs tipe =\n    case tipe of\n        Type.Lambda arg result ->\n            collectArgs (arg :: revArgs) result\n\n        _ ->\n            List.reverse (tipe :: revArgs)\n\n\nlambdaOne : OneSettings (Lines (Line msg)) msg\nlambdaOne =\n    { open = []\n    , sep = [ text \" -> \" ]\n    , close = []\n    , openWidth = 0\n    , sepWidth = 2\n    , closeWidth = 0\n    , toLine = toLine\n    }\n\n\nlambdaMore : MoreSettings (Lines (Line msg)) msg\nlambdaMore =\n    { open = []\n    , sep = text \"-> \"\n    , close = Nothing\n    , openIndent = 0\n    , sepIndent = 3\n    , toLines = toOneOrMore\n    }\n\n\nlambdaOneParens : OneSettings (Lines (Line msg)) msg\nlambdaOneParens =\n    { open = [ text \"(\" ]\n    , sep = [ text \" -> \" ]\n    , close = [ text \")\" ]\n    , openWidth = 1\n    , sepWidth = 2\n    , closeWidth = 1\n    , toLine = toLine\n    }\n\n\nlambdaMoreParens : MoreSettings (Lines (Line msg)) msg\nlambdaMoreParens =\n    { open = [ text \"( \" ]\n    , sep = text \"  -> \"\n    , close = Just [ text \")\" ]\n    , openIndent = 2\n    , sepIndent = 5\n    , toLines = toOneOrMore\n    }\n\n\n\n-- TUPLES\n\n\ntupleOne : OneSettings (Lines (Line msg)) msg\ntupleOne =\n    { open = [ text \"( \" ]\n    , sep = [ text \", \" ]\n    , close = [ text \" )\" ]\n    , openWidth = 2\n    , sepWidth = 2\n    , closeWidth = 2\n    , toLine = toLine\n    }\n\n\ntupleMore : MoreSettings (Lines (Line msg)) msg\ntupleMore =\n    { open = [ text \"( \" ]\n    , sep = text \", \"\n    , close = Just [ text \")\" ]\n    , openIndent = 2\n    , sepIndent = 2\n    , toLines = toOneOrMore\n    }\n\n\n\n-- TYPES\n\n\ntypeOne : Bool -> OneSettings (Lines (Line msg)) msg\ntypeOne needsParens =\n    if needsParens then\n        { open = [ text \"(\" ]\n        , sep = [ text \" \" ]\n        , close = [ text \")\" ]\n        , openWidth = 1\n        , sepWidth = 1\n        , closeWidth = 1\n        , toLine = toLine\n        }\n\n    else\n        { open = []\n        , sep = [ text \" \" ]\n        , close = []\n        , openWidth = 0\n        , sepWidth = 1\n        , closeWidth = 0\n        , toLine = toLine\n        }\n\n\ntypeMore : Bool -> MoreSettings (Lines (Line msg)) msg\ntypeMore needsParens =\n    if needsParens then\n        { open = [ text \"(\" ]\n        , sep = text \"    \"\n        , close = Just [ text \")\" ]\n        , openIndent = 0\n        , sepIndent = 4\n        , toLines = toOneOrMore\n        }\n\n    else\n        { open = []\n        , sep = text \"    \"\n        , close = Nothing\n        , openIndent = 0\n        , sepIndent = 4\n        , toLines = toOneOrMore\n        }\n\n\n\n-- RECORDS\n\n\nrecordOne : OneSettings ( String, Lines (Line msg) ) msg\nrecordOne =\n    { open = [ text \"{ \" ]\n    , sep = [ text \", \" ]\n    , close = [ text \" }\" ]\n    , openWidth = 2\n    , sepWidth = 2\n    , closeWidth = 2\n    , toLine = fieldToLine\n    }\n\n\nrecordMore : MoreSettings ( String, Lines (Line msg) ) msg\nrecordMore =\n    { open = [ text \"{ \" ]\n    , sep = text \", \"\n    , close = Just [ text \"}\" ]\n    , openIndent = 6\n    , sepIndent = 6\n    , toLines = fieldToLines\n    }\n\n\n\n-- EXTENDED RECORDS\n\n\nrecordOneExt : String -> OneSettings ( String, Lines (Line msg) ) msg\nrecordOneExt extension =\n    let\n        open =\n            \"{ \" ++ extension ++ \" | \"\n    in\n    { open = [ text open ]\n    , sep = [ text \", \" ]\n    , close = [ text \" }\" ]\n    , openWidth = String.length open\n    , sepWidth = 2\n    , closeWidth = 2\n    , toLine = fieldToLine\n    }\n\n\nrecordMoreExt : MoreSettings ( String, Lines (Line msg) ) msg\nrecordMoreExt =\n    { open = [ text \"    | \" ]\n    , sep = text \"    , \"\n    , close = Nothing\n    , openIndent = 10\n    , sepIndent = 10\n    , toLines = fieldToLines\n    }\n\n\n\n-- RECORD HELPERS\n\n\nfieldToLine : ( String, Lines (Line msg) ) -> Maybe ( Int, Line msg )\nfieldToLine ( field, lines ) =\n    case lines of\n        More _ _ ->\n            Nothing\n\n        One width line ->\n            Just ( String.length field + 3 + width, text field :: space :: colon :: space :: line )\n\n\nfieldToLines : ( String, Lines (Line msg) ) -> OneOrMore (Line msg)\nfieldToLines ( field, lines ) =\n    case lines of\n        One width line ->\n            let\n                potentialWidth =\n                    String.length field + 3 + width\n            in\n            if potentialWidth < maxWidth then\n                OneOrMore (text field :: space :: colon :: space :: line) []\n\n            else\n                OneOrMore [ text field, space, colon ] [ line ]\n\n        More x xs ->\n            OneOrMore [ text field, space, colon ] (x :: xs)\n\n\n\n-- HELPERS\n\n\ntoLine : Lines line -> Maybe ( Int, line )\ntoLine lines =\n    case lines of\n        One width line ->\n            Just ( width, line )\n\n        More _ _ ->\n            Nothing\n\n\nlinesToList : Lines line -> List line\nlinesToList lines =\n    case lines of\n        One _ line ->\n            [ line ]\n\n        More x xs ->\n            x :: xs\n\n\ntype OneOrMore a\n    = OneOrMore a (List a)\n\n\ntoOneOrMore : Lines line -> OneOrMore line\ntoOneOrMore lines =\n    case lines of\n        One _ line ->\n            OneOrMore line []\n\n        More x xs ->\n            OneOrMore x xs\n\n\n\n-- TO LINES HELP\n\n\ntype alias OneSettings a msg =\n    { open : Line msg\n    , sep : Line msg\n    , close : Line msg\n    , openWidth : Int\n    , sepWidth : Int\n    , closeWidth : Int\n    , toLine : a -> Maybe ( Int, Line msg )\n    }\n\n\ntype alias MoreSettings a msg =\n    { open : Line msg\n    , sep : Html msg\n    , close : Maybe (Line msg)\n    , openIndent : Int\n    , sepIndent : Int\n    , toLines : a -> OneOrMore (Line msg)\n    }\n\n\ntoLinesHelp : OneSettings a msg -> MoreSettings a msg -> a -> List a -> Lines (Line msg)\ntoLinesHelp one more x xs =\n    let\n        maybeOneLine =\n            toOneLine one.openWidth one.open one (x :: xs)\n    in\n    case maybeOneLine of\n        Just ( width, line ) ->\n            One width line\n\n        Nothing ->\n            toMoreLines more x xs\n\n\ntoOneLine : Int -> Line msg -> OneSettings a msg -> List a -> Maybe ( Int, Line msg )\ntoOneLine chunkWidth chunk one entries =\n    case entries of\n        [] ->\n            Just ( one.closeWidth, one.close )\n\n        entry :: remainingEntries ->\n            case one.toLine entry of\n                Nothing ->\n                    Nothing\n\n                Just ( entryWidth, line ) ->\n                    case toOneLine one.sepWidth one.sep one remainingEntries of\n                        Nothing ->\n                            Nothing\n\n                        Just ( remainingWidth, remainingLine ) ->\n                            let\n                                width =\n                                    chunkWidth + entryWidth + remainingWidth\n                            in\n                            if width < maxWidth then\n                                Just ( width, chunk ++ line ++ remainingLine )\n\n                            else\n                                Nothing\n\n\ntoMoreLines : MoreSettings a msg -> a -> List a -> Lines (Line msg)\ntoMoreLines s x xs =\n    let\n        (OneOrMore firstLine firstRest) =\n            s.toLines x\n\n        openIndentation =\n            text (String.repeat s.openIndent \" \")\n\n        sepIndentation =\n            text (String.repeat s.sepIndent \" \")\n\n        toChunk (OneOrMore y ys) =\n            (s.sep :: y) :: List.map ((::) sepIndentation) ys\n\n        otherLines =\n            List.map ((::) openIndentation) firstRest\n                ++ List.concatMap (toChunk << s.toLines) xs\n    in\n    More (s.open ++ firstLine) <|\n        case s.close of\n            Nothing ->\n                otherLines\n\n            Just closer ->\n                otherLines ++ [ closer ]\n\n\n\n-- HELPERS\n\n\nkeyword : String -> Html msg\nkeyword kw =\n    span [ class \"hljs-keyword\" ] [ text kw ]\n\n\nspace : Html msg\nspace =\n    text \" \"\n\n\narrow : Html msg\narrow =\n    span [] [ text \"->\" ]\n\n\ncolon : Html msg\ncolon =\n    span [] [ text \":\" ]\n\n\nequals : Html msg\nequals =\n    span [] [ text \"=\" ]\n"
}

export const Ui_Attr = {
   moduleName: "Ui.Attr",
   path: "/Ui/Attr.elm",
   contents: "module Ui.Attr exposing\n    ( alignTop\n    , borderBox\n    , ellipsis\n    , gap\n    , noGrow\n    , noShrink\n    , overflowHidden\n    , pad\n    , padXY\n    , scrollbars\n    , width\n    , widthMax\n    )\n\nimport Html exposing (Html)\nimport Html.Attributes as Attr\n\n\nalignTop : Html.Attribute msg\nalignTop =\n    -- Attr.style \"align-items\" \"flex-start\"\n    Attr.class \"\"\n\n\noverflowHidden : Html.Attribute msg\noverflowHidden =\n    Attr.style \"overflow\" \"hidden\"\n\n\nscrollbars : Html.Attribute msg\nscrollbars =\n    Attr.style \"overflow\" \"auto\"\n\n\nborderBox : Html.Attribute msg\nborderBox =\n    Attr.style \"box-sizing\" \"border-box\"\n\n\nellipsis : Html.Attribute msg\nellipsis =\n    Attr.class \"ellipsis\"\n\n\nnoGrow : Html.Attribute msg\nnoGrow =\n    Attr.style \"flex-grow\" \"0\"\n\n\nnoShrink : Html.Attribute msg\nnoShrink =\n    Attr.style \"flex-shrink\" \"0\"\n\n\nwidthMax : Int -> Html.Attribute msg\nwidthMax n =\n    Attr.style \"max-width\" (String.fromInt n ++ \"px\")\n\n\nwidth : Int -> Html.Attribute msg\nwidth n =\n    Attr.style \"width\" (String.fromInt n ++ \"px\")\n\n\npadXY : Int -> Int -> Html.Attribute msg\npadXY x y =\n    Attr.style \"padding\" (String.fromInt y ++ \"px \" ++ String.fromInt x ++ \"px\")\n\n\npad : Int -> Html.Attribute msg\npad n =\n    Attr.style \"padding\" (String.fromInt n ++ \"px\")\n\n\ngap : Int -> Html.Attribute msg\ngap n =\n    Attr.style \"gap\" (String.fromInt n ++ \"px\")\n"
}

export const Ui_Markdown = {
   moduleName: "Ui.Markdown",
   path: "/Ui/Markdown.elm",
   contents: "module Ui.Markdown exposing (view)\n\nimport Html exposing (Html)\nimport Html.Attributes\nimport Markdown.Parser\nimport Markdown.Renderer\n\n\nview : String -> Html msg\nview markdown =\n    let\n        parsedResult =\n            Markdown.Parser.parse markdown\n    in\n    case parsedResult of\n        Err _ ->\n            Html.div\n                [ Html.Attributes.class \"markdown\" ]\n                [ Html.text \"Error parsing markdown\" ]\n\n        Ok parsed ->\n            Html.div\n                [ Html.Attributes.class \"markdown\" ]\n                (case Markdown.Renderer.render Markdown.Renderer.defaultHtmlRenderer parsed of\n                    Err errString ->\n                        [ Html.text errString ]\n\n                    Ok rendered ->\n                        rendered\n                )\n"
}

export const Ui_Nav = {
   moduleName: "Ui.Nav",
   path: "/Ui/Nav.elm",
   contents: "module Ui.Nav exposing (view)\n\nimport App.Route\nimport Docs.Packages\nimport Elm.Docs\nimport Html exposing (Html)\nimport Html.Attributes as Attr\nimport Theme\nimport Ui.Attr\n\n\npadding : Int\npadding =\n    24\n\n\nwidth : Int\nwidth =\n    256\n\n\nview : {} -> Html msg\nview options =\n    Html.nav\n        [ Ui.Attr.width width\n        , Ui.Attr.widthMax width\n        , Ui.Attr.noShrink\n        , Ui.Attr.noGrow\n        , Ui.Attr.borderBox\n        , heightWindow\n        ]\n        [ Html.div\n            [ Attr.style \"position\" \"fixed\"\n            , heightWindow\n            , Ui.Attr.pad padding\n            , Ui.Attr.width width\n            , Ui.Attr.widthMax width\n            , Ui.Attr.borderBox\n            , Ui.Attr.scrollbars\n            , Attr.class \"navbar\"\n            ]\n            [ viewSection \"Guides\"\n                ()\n            , viewSection \"Packages\"\n                (List.map viewPackage Docs.Packages.directory)\n            ]\n        ]\n\n\nheightWindow =\n    Attr.style \"height\" \"100vh\"\n\n\nviewSection : String -> List (Html msg) -> Html msg\nviewSection title items =\n    Theme.column.sm []\n        [ Html.h2 [ Ui.pad 0 ] [ Html.text title ]\n        , Theme.column.zero [ Ui.gap -2 ] items\n        ]\n\n\nviewPackage : { name : String, modules : List Elm.Docs.Module } -> Html msg\nviewPackage package =\n    Html.div []\n        [ Html.a\n            [ Attr.href\n                (App.Route.toString\n                    (App.Route.Package { path_ = String.split \"/\" package.name })\n                )\n            , Ui.Attr.ellipsis\n            , Ui.Attr.width (width - (padding * 2))\n            , Attr.style \"display\" \"inline-block\"\n            ]\n            [ Html.text package.name ]\n        ]\n"
}

export const Ui_Syntax = {
   moduleName: "Ui.Syntax",
   path: "/Ui/Syntax.elm",
   contents: "module Ui.Syntax exposing (field, keyword, punctuation, type_, typevar)\n\nimport Html\nimport Html.Attributes as Attr\n\n\ntypevar : Html.Attribute msg\ntypevar =\n    Attr.class \"typevar\"\n\n\npunctuation : Html.Attribute msg\npunctuation =\n    Attr.class \"punctuation\"\n\n\ntype_ : Html.Attribute msg\ntype_ =\n    Attr.class \"type\"\n\n\nfield : Html.Attribute msg\nfield =\n    Attr.class \"field\"\n\n\nkeyword : Html.Attribute msg\nkeyword =\n    Attr.class \"keyword\"\n"
}

export const Ui_Type = {
   moduleName: "Ui.Type",
   path: "/Ui/Type.elm",
   contents: "module Ui.Attr.Type exposing (view)\n\nimport Elm.Type\nimport Html exposing (Html)\nimport Theme\nimport Ui.Attr.Attr\nimport Ui.Attr.Syntax as Syntax\n\n\nshouldBeMultiline : Elm.Type.Type -> Bool\nshouldBeMultiline tipe =\n    linearWidth tipe > 50\n\n\n{-| View a type definition\n-}\nview : Elm.Type.Type -> Html msg\nview tipe =\n    viewNew (shouldBeMultiline tipe) 0 tipe\n        |> .content\n\n\nlinearWidth : Elm.Type.Type -> Int\nlinearWidth tipe =\n    case tipe of\n        Elm.Type.Var var ->\n            String.length var\n\n        Elm.Type.Lambda one two ->\n            linearWidth one + linearWidth two + 4\n\n        Elm.Type.Tuple vals ->\n            4\n                + sumWith linearWidth vals\n                + spacingWidth 2 vals\n\n        Elm.Type.Type typename varTypes ->\n            String.length typename\n                + sumWith linearWidth varTypes\n                + spacingWidth 1 varTypes\n\n        Elm.Type.Record fields Nothing ->\n            recordWidth\n                + sumWith\n                    (\\( name, fieldType ) ->\n                        4 + String.length name + linearWidth fieldType\n                    )\n                    fields\n                + spacingWidth 2 fields\n\n        Elm.Type.Record fields (Just extensibleName) ->\n            String.length extensibleName\n                + recordWidth\n                + sumWith\n                    (\\( name, fieldType ) ->\n                        3 + String.length name + linearWidth fieldType\n                    )\n                    fields\n                + spacingWidth 2 fields\n\n\nsumWith : (a -> Int) -> List a -> Int\nsumWith toSize items =\n    List.foldl (\\v sum -> sum + toSize v) 0 items\n\n\nspacingWidth : Int -> List a -> Int\nspacingWidth spacing items =\n    case items of\n        [] ->\n            0\n\n        [ _ ] ->\n            0\n\n        [ _, _ ] ->\n            spacing\n\n        [ _, _, _ ] ->\n            spacing + spacing\n\n        _ ->\n            (List.length items - 1) * spacing\n\n\n{-| curly braces and a space on each side\n-}\nrecordWidth : Int\nrecordWidth =\n    4\n\n\nindentPadding : Int -> Html.Attribute msg\nindentPadding indent =\n    Ui.Attr.padXY\n        (indent * 8)\n        0\n\n\nparens : Html msg -> Html msg\nparens content =\n    Theme.row.zero []\n        [ punctuation \"(\"\n        , content\n        , punctuation \")\"\n        ]\n\n\nverticalParens : Html msg -> Html msg\nverticalParens content =\n    Theme.column.zero []\n        [ Theme.row.zero []\n            [ Theme.el\n                [ Ui.Attr.alignTop\n                , Syntax.punctuation\n                ]\n                (Html.text \"(\")\n            , content\n            ]\n        , punctuation \")\"\n        ]\n\n\naddParens : Elm.Type.Type -> Html msg -> Html msg\naddParens tipe elem =\n    case tipe of\n        Elm.Type.Lambda _ _ ->\n            parens elem\n\n        Elm.Type.Type _ [] ->\n            elem\n\n        Elm.Type.Type _ _ ->\n            parens elem\n\n        _ ->\n            elem\n\n\naddParensInFunction :\n    Elm.Type.Type\n    ->\n        { content : Html msg\n        , multiline : Bool\n        }\n    -> Html msg\naddParensInFunction tipe elem =\n    case tipe of\n        Elm.Type.Lambda _ _ ->\n            if elem.multiline then\n                verticalParens elem.content\n\n            else\n                parens elem.content\n\n        _ ->\n            elem.content\n\n\nviewNew :\n    Bool\n    -> Int\n    -> Elm.Type.Type\n    ->\n        { content : Html msg\n        , multiline : Bool\n        }\nviewNew forceMultiline indent tipe =\n    case tipe of\n        Elm.Type.Var var ->\n            { multiline = forceMultiline\n            , content = Theme.el [ Syntax.typevar, Ui.Attr.alignTop ] (Html.text var)\n            }\n\n        Elm.Type.Lambda one two ->\n            let\n                oneRendered =\n                    viewNew forceMultiline indent one\n\n                twoRendered =\n                    viewFnArgs forceMultiline indent two\n\n                multiline =\n                    forceMultiline || oneRendered.multiline || twoRendered.multiline\n\n                realMultiline =\n                    if multiline then\n                        multiline\n\n                    else\n                        linearWidth tipe > 50\n            in\n            { multiline = realMultiline\n            , content =\n                columnIf realMultiline\n                    []\n                    (addParensInFunction one oneRendered\n                        :: twoRendered.items\n                    )\n            }\n\n        Elm.Type.Tuple vals ->\n            let\n                renderedItems =\n                    viewList forceMultiline\n                        indent\n                        (viewNew forceMultiline (indent + 4))\n                        vals\n                        { rowSpacer = Theme.el [ Syntax.punctuation ] (Html.text \", \")\n                        , columnSpacer = Theme.el [ Syntax.punctuation ] (Html.text \", \")\n                        }\n            in\n            { multiline = forceMultiline || renderedItems.multiline\n            , content =\n                renderedItems.content\n                    |> parens\n            }\n\n        Elm.Type.Type typename [] ->\n            { multiline = forceMultiline\n            , content = Theme.el [ Syntax.type_, Ui.Attr.alignTop ] (Html.text typename)\n            }\n\n        Elm.Type.Type typename varTypes ->\n            let\n                renderedItems =\n                    viewList forceMultiline\n                        indent\n                        (\\var ->\n                            let\n                                rendered =\n                                    viewNew forceMultiline (indent + 4) var\n                            in\n                            { content =\n                                addParens\n                                    var\n                                    rendered.content\n                            , multiline = rendered.multiline\n                            }\n                        )\n                        varTypes\n                        { rowSpacer = Html.text \" \"\n                        , columnSpacer = Ui.Attr.none\n                        }\n            in\n            { multiline = forceMultiline || renderedItems.multiline\n            , content =\n                columnIf (forceMultiline || renderedItems.multiline)\n                    []\n                    [ Theme.row.zero [ Ui.Attr.alignTop ]\n                        [ Theme.el [ Ui.Attr.alignTop, Syntax.type_ ] (Html.text typename)\n                        , Html.text \" \"\n                        ]\n                    , if forceMultiline || renderedItems.multiline then\n                        Theme.row.zero []\n                            [ Html.text \"    \"\n                            , renderedItems.content\n                            ]\n\n                      else\n                        renderedItems.content\n                    ]\n            }\n\n        Elm.Type.Record fields maybeExtensibleName ->\n            List.foldl\n                (\\( name, type_ ) cursor ->\n                    let\n                        fieldContent =\n                            viewNew False (indent + 4) type_\n                    in\n                    { isFirst = False\n                    , content =\n                        columnIf fieldContent.multiline\n                            []\n                            [ Theme.row.zero [ Ui.Attr.alignTop, Syntax.field ]\n                                [ if cursor.isFirst then\n                                    Theme.row.zero []\n                                        [ punctuation \"{ \"\n                                        , case maybeExtensibleName of\n                                            Nothing ->\n                                                Ui.Attr.none\n\n                                            Just recordName ->\n                                                fieldName recordName\n                                        , case maybeExtensibleName of\n                                            Nothing ->\n                                                Ui.Attr.none\n\n                                            Just recordName ->\n                                                punctuation \" | \"\n                                        ]\n\n                                  else\n                                    punctuation \", \"\n                                , fieldName name\n                                , keyword \" : \"\n                                ]\n                            , if fieldContent.multiline then\n                                Theme.row.zero []\n                                    [ Html.text \"    \"\n                                    , fieldContent.content\n                                    ]\n\n                              else\n                                fieldContent.content\n                            ]\n                            :: cursor.content\n                    , multiline = cursor.multiline || fieldContent.multiline\n                    }\n                )\n                { isFirst = True\n                , content = []\n                , multiline = True --List.length fields > 1\n                }\n                fields\n                |> (\\result ->\n                        { multiline = result.multiline\n                        , content =\n                            Theme.column.zero [ Ui.Attr.gap 4 ]\n                                ((punctuation \"}\" :: result.content)\n                                    |> List.reverse\n                                )\n                        }\n                   )\n\n\nkeyword str =\n    Theme.el [ Syntax.keyword ] (Html.text str)\n\n\nfieldName str =\n    Theme.el [ Syntax.field ] (Html.text str)\n\n\npunctuation str =\n    Theme.el [ Syntax.punctuation ] (Html.text str)\n\n\nviewList :\n    Bool\n    -> Int\n    ->\n        (Elm.Type.Type\n         ->\n            { content : Html msg\n            , multiline : Bool\n            }\n        )\n    -> List Elm.Type.Type\n    ->\n        { rowSpacer : Html msg\n        , columnSpacer : Html msg\n        }\n    ->\n        { content : Html msg\n        , multiline : Bool\n        }\nviewList forceMultiline indent viewItem items spacer =\n    List.foldl\n        (\\type_ cursor ->\n            let\n                fieldContent =\n                    viewItem type_\n            in\n            { isFirst = False\n            , content =\n                columnIf (forceMultiline || fieldContent.multiline)\n                    []\n                    [ Theme.row.zero []\n                        [ if cursor.isFirst then\n                            Ui.Attr.none\n\n                          else if forceMultiline || fieldContent.multiline then\n                            spacer.columnSpacer\n\n                          else\n                            spacer.rowSpacer\n                        , fieldContent.content\n                        ]\n                    ]\n                    :: cursor.content\n            , multiline = cursor.multiline || fieldContent.multiline\n            }\n        )\n        { isFirst = True\n        , content = []\n        , multiline = False\n        }\n        items\n        |> (\\result ->\n                { multiline = result.multiline\n                , content =\n                    columnIf result.multiline\n                        []\n                        (result.content\n                            |> List.reverse\n                        )\n                }\n           )\n\n\nviewFnArgs :\n    Bool\n    -> Int\n    -> Elm.Type.Type\n    ->\n        { items : List (Html msg)\n        , multiline : Bool\n        }\nviewFnArgs forceMultiline indent tipe =\n    case tipe of\n        Elm.Type.Lambda one two ->\n            let\n                new =\n                    viewNew False indent one\n\n                args =\n                    viewFnArgs forceMultiline indent two\n            in\n            { multiline = args.multiline\n            , items =\n                Theme.row.zero [ Ui.Attr.alignTop ]\n                    [ arrowRight (forceMultiline || args.multiline)\n                    , new.content\n                    ]\n                    :: args.items\n            }\n\n        everythingElse ->\n            let\n                new =\n                    viewNew False indent everythingElse\n            in\n            { multiline = new.multiline\n            , items =\n                [ Theme.row.zero [ Ui.Attr.alignTop ]\n                    [ arrowRight (forceMultiline || new.multiline)\n                    , new.content\n                    ]\n                ]\n            }\n\n\ncolumnIf : Bool -> List (Html.Attribute msg) -> List (Html msg) -> Html msg\ncolumnIf on attrs children =\n    if on then\n        Theme.column.zero (Ui.Attr.gap 4 :: attrs) children\n\n    else\n        Theme.row.zero attrs children\n\n\narrowRight : Bool -> Html msg\narrowRight multiline =\n    if multiline then\n        Theme.el [ Ui.Attr.alignTop, Syntax.keyword ] (Html.text \"-> \")\n\n    else\n        Theme.el [ Ui.Attr.alignTop, Syntax.keyword ] (Html.text \" -> \")\n"
}

export const Main = {
   moduleName: "Main",
   path: "/Main.elm",
   contents: "module Main exposing (main)\n\n{-| -}\n\nimport App\nimport App.Resources\nimport App.View\nimport Browser\nimport Effect exposing (Effect)\nimport Effect.Nav\nimport Effect.Scroll\nimport Html\nimport Html.Attributes as Attr\nimport Listen\nimport Ui\nimport Ui.Nav\nimport Url\n\n\ntype alias Model =\n    {}\n\n\n{-| -}\nmain : App.App Model Msg\nmain =\n    App.app\n        { init =\n            \\resources flags url ->\n                ( {}, Effect.Nav.toUrl url )\n        , onUrlChange = UrlChanged\n        , onUrlRequest = UrlRequested\n        , update = update\n        , subscriptions =\n            \\resources model ->\n                Listen.none\n        , toCmd = toCmd\n        , toSub = toSub\n        , view =\n            \\resources toAppMsg model regions ->\n                case regions.primary of\n                    Nothing ->\n                        { title = \"Nothing\"\n                        , body = [ Html.text \"Nothing\" ]\n                        }\n\n                    Just (App.Loading _) ->\n                        { title = \"Loading\"\n                        , body = [ Html.text \"Loading\" ]\n                        }\n\n                    Just App.NotFound ->\n                        --\n                        { title = \"Not found\"\n                        , body = [ Html.text \"Not found\" ]\n                        }\n\n                    Just (App.Error error) ->\n                        -- error is a type you control that lives at App.Page.Error\n                        { title = \"Not found\"\n                        , body = [ Html.text \"Not found\" ]\n                        }\n\n                    Just (App.View page) ->\n                        view resources toAppMsg model page\n        }\n\n\ntoSub : App.Resources.Resources -> App.SubOptions Msg -> Model -> Listen.Listen (App.Msg Msg) -> Sub (App.Msg Msg)\ntoSub resources options model sub =\n    Listen.toSubscription options sub\n\n\ntoCmd : App.Resources.Resources -> App.CmdOptions Msg -> Model -> Effect.Effect (App.Msg Msg) -> Cmd (App.Msg Msg)\ntoCmd resources options model effect =\n    Effect.toCmd options\n        (\\urlBase ->\n            case urlBase of\n                Effect.UrlApi ->\n                    { headers = []\n                    , urlBase = \"\"\n                    }\n\n                Effect.UrlStaticFile ->\n                    { headers = []\n                    , urlBase = \"\"\n                    }\n\n                Effect.UrlCustom base ->\n                    { headers = []\n                    , urlBase = base\n                    }\n        )\n        effect\n\n\nheightWindow =\n    Attr.style \"height\" \"100vh\"\n\n\nview :\n    App.Resources.Resources\n    -> (Msg -> App.Msg Msg)\n    -> Model\n    -> App.View.View (App.Msg Msg)\n    -> Browser.Document (App.Msg Msg)\nview resources toAppMsg model innerView =\n    { title = innerView.title\n    , body =\n        [ stylesheet\n        , Ui.row.zero [ heightWindow ]\n            [ Ui.Nav.view {}\n            , Html.div\n                [ heightWindow\n                ]\n                [ innerView.body ]\n            ]\n        ]\n    }\n\n\nstylesheet =\n    Html.node \"style\"\n        []\n        [ Html.text \"\"\"\nhtml, head, body {\n  margin: 0;\n}\n\nbody {\n  font-family: 'Source Sans Pro', 'Trebuchet MS', 'Lucida Grande', 'Bitstream Vera Sans', 'Helvetica Neue', sans-serif;\n  color: #000E16;\n  display: flex;\n  min-height: 100vh;\n  flex-direction: column;\n}\n\nh1, h2, h3, h4 {\n  font-weight: normal;\n  margin:0;\n}\n\np, li {\n  line-height: 1.5em;\n}\n\na { color: #1293D8; text-decoration: none; }\na:hover { text-decoration: underline; }\na .light { color: #5FABDC; }\n\npre {\n  margin: 0;\n  padding: 10px;\n  background-color: rgb(254,254,254);\n  border-style: solid;\n  border-width: 1px;\n  border-color: rgb(245,245,245);\n  border-radius: 6px;\n  overflow-x: auto;\n}\n\n\n\n/* HOME */\n\n.home-summaries ul {\n  list-style-type: none;\n  padding-left: 1em;\n}\n\n\n\n/* CENTER */\n\n.center {\n  width: 920px;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n\n\n/* HEADER */\n\n.header {\n  background-color: #5FABDC;\n  width: calc(100% - 40px);\n  padding-left: 20px;\n  padding-right: 20px;\n  overflow-x: hidden;\n}\n\n.nav {\n  max-width: 920px;\n  height: 64px;\n  margin: 0 auto;\n  display: flex;\n  align-items: center;\n}\n\n.nav { color: white; }\n.nav a { color: white; }\n.nav h1 { font-size: 24px; }\n.spacey-char { margin: 0 10px; }\n\n.header-underbar {\n  background-color: #f2e19e;\n  margin: 0;\n}\n\n.version-warning {\n  margin: 0 0 0 calc((100% - 920px) / 2);\n  padding: 7px 0;\n  color: #750707;\n}\n\n.version-warning a {\n  color: #750707;\n  text-decoration: underline;\n}\n\n\n\n/* FOOTER */\n\n\n.footer {\n  text-align: center;\n  margin-top: 4em;\n  border-top: 1px solid #eeeeee;\n  padding: 2em 0;\n  color: #bbbbbb;\n}\n\n\n.grey-link {\n  color: #bbbbbb;\n  text-decoration: underline;\n  cursor: pointer;\n}\n\n.grey-link:hover {\n  color: #bbbbbb;\n}\n\n\n/* DOCUMENTATION */\n\n\n.block-list {\n  width: 600px;\n  display: inline-block;\n  vertical-align: top;\n}\n\n.block-list-title {\n  font-size: 3em;\n  margin-bottom: 16px;\n}\n\n.markdown-block h1 {\n  margin-top: 2em;\n  margin-bottom: 0.5em;\n}\n\n.docs-block {\n  border-top: 1px solid #eeeeee;\n  margin-top: 1em;\n  margin-bottom: 2em;\n}\n\n\n.docs-header {\n  white-space: pre;\n  font-family: 'Source Code Pro', Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  padding-top: 10px;\n  padding-bottom: 10px;\n}\n\n\n.docs-comment {\n  overflow: hidden;\n  padding-left: 36px;\n}\n\n.docs-comment img {\n  max-width: 500px;\n}\n\n\n\n/* ABOUT */\n\n\n.pkg-about table {\n  font-family: 'Source Code Pro', Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  width: 100%;\n}\n\n.pkg-about td {\n  padding: 4px 0;\n}\n\n\n\n/* PACKAGE NAVIGATION */\n\n\n.pkg-nav {\n  width: 200px;\n  display: inline-block;\n  vertical-align: top;\n  padding: 20px;\n  margin: 20px 20px 20px 40px;\n  border-left: 1px solid #eeeeee;\n}\n\n.pkg-nav h2 {\n  margin-bottom: 0;\n}\n\n.pkg-nav input {\n  width: 200px;\n  font-size: 1em;\n  padding: 4px;\n  margin: 10px 0;\n  border: 1px solid #eeeeee;\n  border-radius: 6px;\n}\n\n.pkg-nav ul {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n\n.pkg-nav ul ul {\n  list-style-type: none;\n  margin: 0;\n  padding-left: 20px;\n}\n\n.pkg-nav-module {\n  font-family: 'Source Code Pro', Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  text-overflow: ellipsis;\n}\n\n.pkg-nav-value {\n  font-family: 'Source Code Pro', Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  text-overflow: ellipsis;\n}\n\n.pkg-nav-search-chunk {\n  padding-bottom: 10px;\n}\n\n\n\n/* CATALOG */\n\n\n.catalog {\n  width: 600px;\n  display: inline-block;\n  vertical-align: top;\n}\n\n\n.catalog input {\n  width: 578px;\n  font-size: 1.5em;\n  padding: 10px;\n  outline: none;\n  border: 1px solid #eeeeee;\n  border-radius: 8px;\n  margin-top: 40px;\n  margin-bottom: 10px;\n}\n\n\n.pkg-hint {\n  padding: 20px;\n  background-color: #fcfcfc;\n  border-radius: 8px;\n}\n\n.pkg-summary {\n  padding: 20px 0;\n  border-bottom: 1px solid #eeeeee;\n}\n\n.pkg-summary h1 {\n  margin: 0;\n  font-size: 1.5em;\n  display: inline-block;\n}\n\n.pkg-summary-desc {\n  margin: 0.5em 0;\n}\n\n.pkg-summary-hints {\n  float: right;\n  font-size: 1em;\n  padding-top: 0.5em;\n  color: #bbbbbb;\n}\n\n.pkg-summary-hints a {\n  color: #bbbbbb;\n}\n\n\n\n/* CATALOG SIDEBAR */\n\n\n.catalog-sidebar {\n  width: 200px;\n  display: inline-block;\n  vertical-align: top;\n  padding: 20px;\n  margin: 20px 20px 20px 40px;\n  border-left: 1px solid #eeeeee;\n}\n\n.catalog-sidebar h2 {\n  font-size: 1.5em;\n  padding: 10px;\n  margin: 0;\n}\n\n.catalog-sidebar ul {\n  list-style-type: none;\n  margin: 0;\n  padding-left: 20px;\n  padding-bottom: 10px;\n}\n\n\n\n/* CODE */\n\n\ncode {\n  font-family: 'Source Code Pro', Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n/* I heard using :not() is slow for reflows.\nNot really any of those on the website though AFAIK.\n*/\n:not(pre) > code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(0,0,0,0.04);\n  border-radius: 3px;\n}\n\n:not(pre) > code::before, :not(pre) > code::after {\n  letter-spacing: -0.2em;\n  content: \"\\\\00a0\";\n}\n\n.column {\n  display: flex;\n  flex-direction: column;\n  box-sizing: border-box;\n}\n\n.row {\n  display: flex;\n  flex-direction: row;\n  box-sizing: border-box;\n}\n\n\n.ellipsis {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n\n\n\"\"\"\n        ]\n\n\ntype Msg\n    = UrlChanged Url.Url\n    | UrlRequested Browser.UrlRequest\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, Effect Msg )\nupdate resources msg model =\n    case msg of\n        UrlRequested (Browser.Internal url) ->\n            ( model, Effect.Nav.pushUrl (Url.toString url) )\n\n        UrlRequested (Browser.External urlStr) ->\n            ( model, Effect.Nav.load urlStr )\n\n        UrlChanged url ->\n            ( model\n            , Effect.batch\n                [ Effect.Nav.toUrl url\n                , Effect.Scroll.resetWindow\n                ]\n            )\n"
}

export const all = [
  Page_Guide,
  Page_Home,
  Page_Module,
  Page_Package,
  Ui_Docs_Block,
  Ui_Attr,
  Ui_Markdown,
  Ui_Nav,
  Ui_Syntax,
  Ui_Type,
  Main
]

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => {
   for (const file of all) {
      if (overwrite || (!fs.existsSync(path.join(baseDir, file.path)) && !skip)) {
        const filepath = path.join(baseDir, file.path);
        fs.mkdirSync(path.dirname(filepath), { recursive: true });
        fs.writeFileSync(filepath, file.contents);
        const generated = { outputDir: baseDir, path: filepath}
        Options.addGenerated(summary, generated);
      }
   }
}
