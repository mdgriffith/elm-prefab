
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => { 
  
  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Page.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Page.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Page exposing\n    ( Page, page\n    , Init, init, initWith, notFound, loadFrom, error\n    , withGuard, withKey, withPageCacheLimit\n    , InitPlan(..), toInternalDetails, mapInitPlan\n    )\n\n{-|\n\n@docs Page, page\n\n@docs Init, init, initWith, notFound, loadFrom, error\n\n@docs withGuard, withKey, withPageCacheLimit\n\n\n# Internal Details\n\nThese are used internally and you shouldn't need to worry about them!\n\n@docs InitPlan, toInternalDetails, mapInitPlan\n\n-}\n\nimport App.Effect\nimport App.Page.Error\nimport App.Resources\nimport App.Sub\nimport App.View\nimport App.View.Id\n\n\ntype Page shared params msg model\n    = Page\n        { toKey : Maybe (params -> String)\n        , pageCacheLimit : Int\n        , init : params -> shared -> Maybe model -> Init msg model\n        , update : shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : shared -> model -> App.Sub.Sub msg\n        , view : App.View.Id.Id -> shared -> model -> Result App.Page.Error.Error (App.View.View msg)\n        }\n\n\n{-| -}\npage :\n    { init : params -> App.Resources.Resources -> Maybe model -> Init msg model\n    , update : App.Resources.Resources -> msg -> model -> ( model, App.Effect.Effect msg )\n    , subscriptions : App.Resources.Resources -> model -> App.Sub.Sub msg\n    , view : App.View.Id.Id -> App.Resources.Resources -> model -> App.View.View msg\n    }\n    -> Page App.Resources.Resources params msg model\npage options =\n    Page\n        { toKey = Nothing\n        , pageCacheLimit = 1\n        , init = options.init\n        , update = options.update\n        , subscriptions = options.subscriptions\n        , view =\n            \\region shared model ->\n                Ok (options.view region shared model)\n        }\n\n\n{-| This is the key that is used to store the page's state globally.\n\nIt defaults to the page's name.\n\n-}\nwithKey : (params -> String) -> Page shared params msg model -> Page shared params msg model\nwithKey toKey (Page options) =\n    Page { options | toKey = Just toKey }\n\n\n{-| This is the maximum number of page instances that will be cached, above what is already visible.\n\nThis defaults to 1.\n\n-}\nwithPageCacheLimit : Int -> Page shared params msg model -> Page shared params msg model\nwithPageCacheLimit limit (Page options) =\n    Page { options | pageCacheLimit = max 0 limit }\n\n\n{-| -}\nwithGuard :\n    (resources -> Result App.Page.Error.Error newResources)\n    -> Page newResources params msg model\n    -> Page resources params msg model\nwithGuard toResources (Page options) =\n    Page\n        { toKey = options.toKey\n        , pageCacheLimit = options.pageCacheLimit\n        , init =\n            \\params resources maybeModel ->\n                case toResources resources of\n                    Err err ->\n                        Error err\n\n                    Ok newShared ->\n                        options.init params newShared maybeModel\n        , update =\n            \\resources msg model ->\n                case toResources resources of\n                    Err err ->\n                        ( model, App.Effect.none )\n\n                    Ok newShared ->\n                        options.update newShared msg model\n        , subscriptions =\n            \\resources model ->\n                case toResources resources of\n                    Err err ->\n                        App.Sub.none\n\n                    Ok newShared ->\n                        options.subscriptions newShared model\n        , view =\n            \\region resources model ->\n                case toResources resources of\n                    Err err ->\n                        Err err\n\n                    Ok newShared ->\n                        options.view region newShared model\n        }\n\n\n{-| -}\ntype alias Init msg model =\n    InitPlan msg model\n\n\n{-| -}\ntype InitPlan msg model\n    = NotFound\n    | Error App.Page.Error.Error\n    | Loaded model (App.Effect.Effect msg)\n    | LoadFrom (App.Effect.Effect (InitPlan msg model))\n\n\n{-| -}\nmapInitPlan :\n    { onModel : model -> model2\n    , onMsg : msg -> msg2\n    }\n    -> InitPlan msg model\n    -> InitPlan msg2 model2\nmapInitPlan ({ onModel, onMsg } as fns) initPlan =\n    case initPlan of\n        NotFound ->\n            NotFound\n\n        Error err ->\n            Error err\n\n        Loaded model effect ->\n            Loaded (onModel model) (App.Effect.map onMsg effect)\n\n        LoadFrom effect ->\n            LoadFrom (App.Effect.map (mapInitPlan fns) effect)\n\n\n{-| -}\ninit : model -> Init msg model\ninit model =\n    Loaded model App.Effect.none\n\n\n{-| -}\ninitWith : model -> App.Effect.Effect msg -> Init msg model\ninitWith model effect =\n    Loaded model effect\n\n\n{-| -}\nnotFound : Init msg model\nnotFound =\n    NotFound\n\n\n{-| -}\nloadFrom : App.Effect.Effect (Init msg model) -> Init msg model\nloadFrom effect =\n    LoadFrom effect\n\n\n{-| -}\nerror : App.Page.Error.Error -> Init msg model\nerror pageError =\n    Error pageError\n\n\n\n{- Internal -}\n\n\n{-| -}\ntoInternalDetails :\n    Page shared params msg model\n    ->\n        { toKey : Maybe (params -> String)\n        , pageCacheLimit : Int\n        , init : params -> shared -> Maybe model -> Init msg model\n        , update : shared -> msg -> model -> ( model, App.Effect.Effect msg )\n        , subscriptions : shared -> model -> App.Sub.Sub msg\n        , view : App.View.Id.Id -> shared -> model -> Result App.Page.Error.Error (App.View.View msg)\n        }\ntoInternalDetails (Page details) =\n    details\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Resource.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Resource.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Resource exposing\n    ( Resource, resource\n    , withLocalStorage\n    )\n\n{-|\n\n@docs Resource, resource\n\n@docs withLocalStorage\n\n-}\n\nimport App.Effect\nimport Json.Decode as Decode\nimport Json.Encode as Json\nimport Url\n\n\n{-| -}\ntype alias Resource msg model =\n    { init : Json.Value -> Url.Url -> Maybe model -> ( model, App.Effect.Effect msg )\n    , update : msg -> model -> ( model, App.Effect.Effect msg )\n    , codec :\n        Maybe\n            { decoder : Decode.Decoder model\n            , encode : model -> Json.Value\n            }\n    }\n\n\n{-| -}\nresource :\n    { init : Json.Value -> Url.Url -> Maybe model -> ( model, App.Effect.Effect msg )\n    , update : msg -> model -> ( model, App.Effect.Effect msg )\n    }\n    -> Resource msg model\nresource options =\n    { init = options.init\n    , update = options.update\n    , codec = Nothing\n    }\n\n\n{-| -}\nwithLocalStorage :\n    { decoder : Decode.Decoder model\n    , encode : model -> Json.Value\n    }\n    -> Resource msg model\n    -> Resource msg model\nwithLocalStorage codec res =\n    { res | codec = Just codec }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/State.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/State.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.State exposing\n    ( Cache, init, get\n    , insert\n    , remove, purge\n    , values\n    , Limit, initLimit\n    , addToLimit, removeFromLimit\n    )\n\n{-|\n\n@docs Cache, init, get\n\n@docs insert\n\n@docs remove, purge\n\n@docs values\n\n@docs Limit, initLimit\n@docs addToLimit, removeFromLimit\n\n-}\n\nimport Dict\nimport Set\n\n\ntype Cache state\n    = Cache (Dict.Dict String state)\n\n\n{-| -}\ninit : Cache state\ninit =\n    Cache Dict.empty\n\n\n{-| -}\nget : String -> Cache state -> Maybe state\nget key (Cache cache) =\n    Dict.get key cache\n\n\n{-| -}\ninsert : String -> state -> Cache state -> Cache state\ninsert key newState (Cache cache) =\n    Cache (Dict.insert key newState cache)\n\n\n{-| -}\nremove : String -> Cache state -> Cache state\nremove key (Cache cache) =\n    Cache (Dict.remove key cache)\n\n\n{-| -}\npurge : List String -> Cache state -> Cache state\npurge keys (Cache cache) =\n    Cache (List.foldl Dict.remove cache keys)\n\n\n{-| -}\nvalues : Cache state -> List state\nvalues (Cache cache) =\n    Dict.values cache\n\n\n{-| A data structure for keeping tracking of the number of instances per page-group we have.\n-}\ntype Limit\n    = Limit (Dict.Dict String (List String))\n\n\n{-| -}\ninitLimit : Limit\ninitLimit =\n    Limit Dict.empty\n\n\n{-| -}\nremoveFromLimit :\n    { groupId : String\n    , instanceId : String\n    }\n    -> Limit\n    -> Limit\nremoveFromLimit { groupId, instanceId } (Limit groups) =\n    let\n        group =\n            Dict.get groupId groups\n                |> Maybe.withDefault []\n\n        newGroup =\n            List.filter (\\id -> id /= instanceId) group\n    in\n    Limit (Dict.insert groupId newGroup groups)\n\n\n{-|\n\n    - group is the page-group name.\n    - instance is the id of the instance.\n    - max is the number of items allowed, ignoring everything in the `keep` set.\n    - keep is a set of ids that should not be removed.\n\n-}\naddToLimit :\n    { groupId : String\n    , instanceId : String\n    , max : Int\n    , keep : Set.Set String\n    }\n    -> Limit\n    ->\n        { limit : Limit\n        , removedIds : List String\n        }\naddToLimit { groupId, instanceId, max, keep } (Limit groups) =\n    let\n        group =\n            Dict.get groupId groups\n                |> Maybe.withDefault []\n\n        ( removableIds, necessaryInstanceIds ) =\n            List.partition (\\id -> id /= instanceId && not (Set.member id keep)) group\n\n        removedIds =\n            -- Remove everything beyond the limit.\n            List.drop max removableIds\n\n        cachedIds =\n            List.take max removableIds\n    in\n    { limit =\n        groups\n            |> Dict.insert groupId\n                (instanceId :: necessaryInstanceIds ++ cachedIds)\n            |> Limit\n    , removedIds = removedIds\n    }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/WebComponent/Portal.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/WebComponent/Portal.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module WebComponent.Portal exposing\n    ( Model, closed\n    , view\n    , MenuPosition(..)\n    , isOpen\n    , Element, Window\n    )\n\n{-| This custom element is helping us with 2 things.\n\nFirst, we need to be able to render dropdown menus at the top of the DOM so they don't accidently get clipped when there are scrollbars.\n\nThe scrollbar clipping thing is a hard blocker from how CSS and stacking contexts work, so our solution is to render it in one place in\nthe DOM in Elm, but have some javascript that moves the element to a place at the top of the DOM behind the scenes.\n\nThis is called a \"portal\" in React land. So, we're just copying that here.\n\nSecond! We also want a drop down to be a drop _up_ if it is too low on the screen. We can do this calculation by capturing bounding boxes and doing some math with the window.\n\nThis element does not care about other styling or behavior though!\n\n@docs Model, closed\n@docs view\n\n@docs MenuPosition\n@docs isOpen\n@docs Element, Window\n\n-}\n\nimport Html exposing (Html)\nimport Html.Attributes as Attr\nimport Html.Events\nimport Json.Decode\n\n\ntype Model\n    = Open Viewport\n    | Closed\n\n\nclosed : Model\nclosed =\n    Closed\n\n\nisOpen : Model -> Bool\nisOpen model =\n    model /= Closed\n\n\ntype alias Viewport =\n    { parent : Element\n    , window : Window\n    }\n\n\ntype alias Element =\n    { x : Float\n    , y : Float\n    , width : Float\n    , height : Float\n    }\n\n\ntype alias Window =\n    { width : Float\n    , height : Float\n    }\n\n\nonToggle :\n    { options\n        | model : Model\n        , onMsg : Model -> msg\n    }\n    -> Html.Attribute msg\nonToggle { model, onMsg } =\n    Html.Events.on \"click\"\n        (Json.Decode.map2\n            (\\parent window ->\n                case model of\n                    Closed ->\n                        onMsg\n                            (Open\n                                { parent = parent\n                                , window = window\n                                }\n                            )\n\n                    Open _ ->\n                        onMsg Closed\n            )\n            (Json.Decode.at [ \"currentTarget\", \"__getParentClientRect\" ] elementDecoder)\n            (Json.Decode.at [ \"currentTarget\", \"__getWindowSize\" ] windowDecode)\n        )\n\n\nwindowDecode : Json.Decode.Decoder Window\nwindowDecode =\n    Json.Decode.map2 Window\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nelementDecoder : Json.Decode.Decoder Element\nelementDecoder =\n    Json.Decode.map4 Element\n        (Json.Decode.field \"x\" Json.Decode.float)\n        (Json.Decode.field \"y\" Json.Decode.float)\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nview :\n    { position : MenuPosition\n    , model : Model\n    , onMsg : Model -> msg\n    , button : Html msg\n    , menu : Html msg\n    }\n    -> Html msg\nview options =\n    let\n        dismissMenuOnEscapeEvent =\n            Html.Events.on \"keyup\"\n                (Json.Decode.field \"key\" Json.Decode.string\n                    |> Json.Decode.andThen\n                        (\\key ->\n                            if key == \"Escape\" then\n                                Json.Decode.succeed (options.onMsg Closed)\n\n                            else\n                                Json.Decode.fail key\n                        )\n                )\n\n        viewMenu : Viewport -> Html msg\n        viewMenu viewport =\n            Html.div\n                [ Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" (px viewport.parent.y)\n                , Attr.style \"left\" (px viewport.parent.x)\n                , Attr.style \"width\" (px viewport.parent.width)\n                , Attr.style \"height\" (px viewport.parent.height)\n                , dismissMenuOnEscapeEvent\n                ]\n                [ Html.div\n                    [ Html.Events.onClick (options.onMsg Closed)\n                    , Attr.style \"position\" \"absolute\"\n                    , Attr.style \"top\" \"0\"\n                    , Attr.style \"left\" \"0\"\n                    , Attr.style \"right\" \"0\"\n                    , Attr.style \"bottom\" \"0\"\n                    ]\n                    []\n                , Html.div\n                    (toPositionAttributes\n                        { position = options.position\n                        , viewport = viewport\n                        }\n                    )\n                    [ options.menu ]\n                ]\n\n        viewDismissOverlay : Html msg\n        viewDismissOverlay =\n            Html.div\n                [ Html.Events.onClick (options.onMsg Closed)\n                , Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" \"0\"\n                , Attr.style \"left\" \"0\"\n                , Attr.style \"width\" \"100%\"\n                , Attr.style \"height\" \"100%\"\n                ]\n                []\n    in\n    Html.div []\n        [ Html.div [ onToggle options ] [ options.button ]\n        , case options.model of\n            Open viewport ->\n                Html.node \"elm-portal\"\n                    []\n                    [ viewDismissOverlay\n                    , viewMenu viewport\n                    ]\n\n            Closed ->\n                Html.text \"\"\n        ]\n\n\ntype MenuPosition\n    = -- Render below toggle button\n      Below { isAlignedLeft : Bool }\n      -- Render to the right of the toggle button\n    | ToRightOf\n\n\ntoPositionAttributes :\n    { position : MenuPosition, viewport : Viewport }\n    -> List (Html.Attribute msg)\ntoPositionAttributes { position, viewport } =\n    let\n        menuBelowRightAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"right\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuBelowLeftAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"left\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightTopAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"top\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightBottomAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"bottom\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        attemptToAlignLeft =\n            if viewport.window.width - viewport.parent.x < 400 then\n                menuBelowRightAligned\n\n            else\n                menuBelowLeftAligned\n\n        attemptToAlignRight =\n            if viewport.parent.x < 400 then\n                menuBelowLeftAligned\n\n            else\n                menuBelowRightAligned\n    in\n    case position of\n        Below { isAlignedLeft } ->\n            if isAlignedLeft then\n                attemptToAlignLeft\n\n            else\n                attemptToAlignRight\n\n        ToRightOf ->\n            if viewport.window.height - viewport.parent.y < 400 then\n                menuOnRightBottomAligned\n\n            else\n                menuOnRightTopAligned\n\n\npx : Float -> String\npx float =\n    String.fromFloat float ++ \"px\"\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }
}
