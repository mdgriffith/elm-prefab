
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => { 
  
  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Page.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Page.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Page exposing\n    ( Page, page\n    , Init, init, initWith, notFound, loadFrom, error\n    , withGuard, withKey, withPageCacheLimit\n    , InitPlan(..), toInternalDetails, mapInitPlan\n    )\n\n{-|\n\n@docs Page, page\n\n@docs Init, init, initWith, notFound, loadFrom, error\n\n@docs withGuard, withKey, withPageCacheLimit\n\n\n# Internal Details\n\nThese are used internally and you shouldn't need to worry about them!\n\n@docs InitPlan, toInternalDetails, mapInitPlan\n\n-}\n\nimport App.Page.Error\nimport App.Resources\nimport App.View\nimport App.View.Id\nimport Effect\nimport Listen\n\n\ntype Page shared params msg model\n    = Page\n        { toKey : Maybe (params -> String)\n        , pageCacheLimit : Int\n        , init : params -> shared -> Maybe model -> Init msg model\n        , update : shared -> msg -> model -> ( model, Effect.Effect msg )\n        , subscriptions : shared -> model -> Listen.Listen msg\n        , view : App.View.Id.Id -> shared -> model -> Result App.Page.Error.Error (App.View.View msg)\n        }\n\n\n{-| -}\npage :\n    { init : params -> App.Resources.Resources -> Maybe model -> Init msg model\n    , update : App.Resources.Resources -> msg -> model -> ( model, Effect.Effect msg )\n    , subscriptions : App.Resources.Resources -> model -> Listen.Listen msg\n    , view : App.View.Id.Id -> App.Resources.Resources -> model -> App.View.View msg\n    }\n    -> Page App.Resources.Resources params msg model\npage options =\n    Page\n        { toKey = Nothing\n        , pageCacheLimit = 1\n        , init = options.init\n        , update = options.update\n        , subscriptions = options.subscriptions\n        , view =\n            \\region shared model ->\n                Ok (options.view region shared model)\n        }\n\n\n{-| This is the key that is used to store the page's state globally.\n\nIt defaults to the page's name.\n\n-}\nwithKey : (params -> String) -> Page shared params msg model -> Page shared params msg model\nwithKey toKey (Page options) =\n    Page { options | toKey = Just toKey }\n\n\n{-| This is the maximum number of page instances that will be cached, above what is already visible.\n\nThis defaults to 1.\n\n-}\nwithPageCacheLimit : Int -> Page shared params msg model -> Page shared params msg model\nwithPageCacheLimit limit (Page options) =\n    Page { options | pageCacheLimit = max 0 limit }\n\n\n{-| -}\nwithGuard :\n    (resources -> Result App.Page.Error.Error newResources)\n    -> Page newResources params msg model\n    -> Page resources params msg model\nwithGuard toResources (Page options) =\n    Page\n        { toKey = options.toKey\n        , pageCacheLimit = options.pageCacheLimit\n        , init =\n            \\params resources maybeModel ->\n                case toResources resources of\n                    Err err ->\n                        Error err\n\n                    Ok newShared ->\n                        options.init params newShared maybeModel\n        , update =\n            \\resources msg model ->\n                case toResources resources of\n                    Err err ->\n                        ( model, Effect.none )\n\n                    Ok newShared ->\n                        options.update newShared msg model\n        , subscriptions =\n            \\resources model ->\n                case toResources resources of\n                    Err err ->\n                        Listen.none\n\n                    Ok newShared ->\n                        options.subscriptions newShared model\n        , view =\n            \\region resources model ->\n                case toResources resources of\n                    Err err ->\n                        Err err\n\n                    Ok newShared ->\n                        options.view region newShared model\n        }\n\n\n{-| -}\ntype alias Init msg model =\n    InitPlan msg model\n\n\n{-| -}\ntype InitPlan msg model\n    = NotFound\n    | Error App.Page.Error.Error\n    | Loaded model (Effect.Effect msg)\n    | LoadFrom (Effect.Effect (InitPlan msg model))\n\n\n{-| -}\nmapInitPlan :\n    { onModel : model -> model2\n    , onMsg : msg -> msg2\n    }\n    -> InitPlan msg model\n    -> InitPlan msg2 model2\nmapInitPlan ({ onModel, onMsg } as fns) initPlan =\n    case initPlan of\n        NotFound ->\n            NotFound\n\n        Error err ->\n            Error err\n\n        Loaded model effect ->\n            Loaded (onModel model) (Effect.map onMsg effect)\n\n        LoadFrom effect ->\n            LoadFrom (Effect.map (mapInitPlan fns) effect)\n\n\n{-| -}\ninit : model -> Init msg model\ninit model =\n    Loaded model Effect.none\n\n\n{-| -}\ninitWith : model -> Effect.Effect msg -> Init msg model\ninitWith model effect =\n    Loaded model effect\n\n\n{-| -}\nnotFound : Init msg model\nnotFound =\n    NotFound\n\n\n{-| -}\nloadFrom : Effect.Effect (Init msg model) -> Init msg model\nloadFrom effect =\n    LoadFrom effect\n\n\n{-| -}\nerror : App.Page.Error.Error -> Init msg model\nerror pageError =\n    Error pageError\n\n\n\n{- Internal -}\n\n\n{-| -}\ntoInternalDetails :\n    Page shared params msg model\n    ->\n        { toKey : Maybe (params -> String)\n        , pageCacheLimit : Int\n        , init : params -> shared -> Maybe model -> Init msg model\n        , update : shared -> msg -> model -> ( model, Effect.Effect msg )\n        , subscriptions : shared -> model -> Listen.Listen msg\n        , view : App.View.Id.Id -> shared -> model -> Result App.Page.Error.Error (App.View.View msg)\n        }\ntoInternalDetails (Page details) =\n    details\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Resource.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Resource.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Resource exposing\n    ( Resource, resource\n    , withLocalStorage\n    )\n\n{-|\n\n@docs Resource, resource\n\n@docs withLocalStorage\n\n-}\n\nimport Effect\nimport Json.Decode as Decode\nimport Json.Encode as Json\nimport Listen\nimport Url\n\n\n{-| -}\ntype alias Resource msg model =\n    { init : Json.Value -> Url.Url -> Maybe model -> ( model, Effect.Effect msg )\n    , update : msg -> model -> ( model, Effect.Effect msg )\n    , subscriptions : model -> Listen.Listen msg\n    , codec :\n        Maybe\n            { decoder : Decode.Decoder model\n            , encode : model -> Json.Value\n            }\n    }\n\n\n{-| -}\nresource :\n    { init : Json.Value -> Url.Url -> Maybe model -> ( model, Effect.Effect msg )\n    , update : msg -> model -> ( model, Effect.Effect msg )\n    , subscriptions : model -> Listen.Listen msg\n    }\n    -> Resource msg model\nresource options =\n    { init = options.init\n    , update = options.update\n    , subscriptions = options.subscriptions\n    , codec = Nothing\n    }\n\n\n{-| -}\nwithLocalStorage :\n    { decoder : Decode.Decoder model\n    , encode : model -> Json.Value\n    }\n    -> Resource msg model\n    -> Resource msg model\nwithLocalStorage codec res =\n    { res | codec = Just codec }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/State.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/State.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.State exposing\n    ( Cache, init, get\n    , insert\n    , remove, purge\n    , values\n    , Limit, initLimit\n    , addToLimit, removeFromLimit\n    )\n\n{-|\n\n@docs Cache, init, get\n\n@docs insert\n\n@docs remove, purge\n\n@docs values\n\n@docs Limit, initLimit\n@docs addToLimit, removeFromLimit\n\n-}\n\nimport Dict\nimport Set\n\n\ntype Cache state\n    = Cache (Dict.Dict String state)\n\n\n{-| -}\ninit : Cache state\ninit =\n    Cache Dict.empty\n\n\n{-| -}\nget : String -> Cache state -> Maybe state\nget key (Cache cache) =\n    Dict.get key cache\n\n\n{-| -}\ninsert : String -> state -> Cache state -> Cache state\ninsert key newState (Cache cache) =\n    Cache (Dict.insert key newState cache)\n\n\n{-| -}\nremove : String -> Cache state -> Cache state\nremove key (Cache cache) =\n    Cache (Dict.remove key cache)\n\n\n{-| -}\npurge : List String -> Cache state -> Cache state\npurge keys (Cache cache) =\n    Cache (List.foldl Dict.remove cache keys)\n\n\n{-| -}\nvalues : Cache state -> List state\nvalues (Cache cache) =\n    Dict.values cache\n\n\n{-| A data structure for keeping tracking of the number of instances per page-group we have.\n-}\ntype Limit\n    = Limit (Dict.Dict String (List String))\n\n\n{-| -}\ninitLimit : Limit\ninitLimit =\n    Limit Dict.empty\n\n\n{-| -}\nremoveFromLimit :\n    { groupId : String\n    , instanceId : String\n    }\n    -> Limit\n    -> Limit\nremoveFromLimit { groupId, instanceId } (Limit groups) =\n    let\n        group =\n            Dict.get groupId groups\n                |> Maybe.withDefault []\n\n        newGroup =\n            List.filter (\\id -> id /= instanceId) group\n    in\n    Limit (Dict.insert groupId newGroup groups)\n\n\n{-|\n\n    - group is the page-group name.\n    - instance is the id of the instance.\n    - max is the number of items allowed, ignoring everything in the `keep` set.\n    - keep is a set of ids that should not be removed.\n\n-}\naddToLimit :\n    { groupId : String\n    , instanceId : String\n    , max : Int\n    , keep : Set.Set String\n    }\n    -> Limit\n    ->\n        { limit : Limit\n        , removedIds : List String\n        }\naddToLimit { groupId, instanceId, max, keep } (Limit groups) =\n    let\n        group =\n            Dict.get groupId groups\n                |> Maybe.withDefault []\n\n        ( removableIds, necessaryInstanceIds ) =\n            List.partition (\\id -> id /= instanceId && not (Set.member id keep)) group\n\n        removedIds =\n            -- Remove everything beyond the limit.\n            List.drop max removableIds\n\n        cachedIds =\n            List.take max removableIds\n    in\n    { limit =\n        groups\n            |> Dict.insert groupId\n                (instanceId :: necessaryInstanceIds ++ cachedIds)\n            |> Limit\n    , removedIds = removedIds\n    }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Clipboard.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Clipboard.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Clipboard exposing (copy)\n\n{-| Copy a value to the clipboard\n-}\n\nimport Effect\nimport Json.Encode as Json\n\n\nport clipboard : Json.Value -> Cmd msg\n\n\ncopy : String -> Effect.Effect msg\ncopy text =\n    Effect.SendToWorld\n        { toPort = clipboard\n        , portName = \"clipboard\"\n        , payload =\n            Json.string text\n        }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Debounce.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Debounce.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Debounce exposing\n    ( init, send\n    , update, Model, Msg\n    )\n\n{-|\n\n@docs init, send\n\n@docs update, Model, Msg\n\n-}\n\nimport Effect exposing (Effect)\nimport Time\n\n\nsend : msg -> Model msg -> Effect (Msg msg)\nsend msg (Model model) =\n    case model.state of\n        NothingToSend ->\n            Effect.now (Start msg)\n\n        WaitingToSend _ previouslySent ->\n            if msg == previouslySent then\n                Effect.none\n\n            else\n                Effect.now (Start msg)\n\n\ntype Model msg\n    = Model\n        { state : State msg\n        , delay : Float\n        }\n\n\ntype State msg\n    = NothingToSend\n    | WaitingToSend Time.Posix msg\n\n\ninit : Float -> Model msg\ninit milliseconds =\n    Model\n        { state = NothingToSend\n        , delay = milliseconds\n        }\n\n\nupdate : (Msg msg -> msg) -> Msg msg -> Model msg -> ( Model msg, Effect msg )\nupdate toMsg msg (Model model) =\n    let\n        paddedDelay =\n            model.delay + 10\n    in\n    case msg of\n        Start msgToSend sentAt ->\n            case model.state of\n                NothingToSend ->\n                    ( Model { model | state = WaitingToSend sentAt msgToSend }\n                    , Effect.map toMsg (waitAndCheck paddedDelay)\n                    )\n\n                WaitingToSend _ previousMsg ->\n                    if msgToSend == previousMsg then\n                        ( Model model, Effect.none )\n\n                    else\n                        ( Model { model | state = WaitingToSend sentAt msgToSend }\n                        , Effect.map toMsg (waitAndCheck paddedDelay)\n                        )\n\n        TimeReceived now ->\n            case model.state of\n                NothingToSend ->\n                    ( Model { model | state = NothingToSend }\n                    , Effect.none\n                    )\n\n                WaitingToSend startedAt sendableMsg ->\n                    let\n                        millisSinceStart =\n                            Time.posixToMillis now - Time.posixToMillis startedAt\n                    in\n                    if toFloat millisSinceStart >= model.delay then\n                        ( Model { model | state = NothingToSend }\n                        , Effect.callback sendableMsg\n                        )\n\n                    else\n                        ( Model model\n                        , Effect.map toMsg (waitAndCheck paddedDelay)\n                        )\n\n\nwaitAndCheck : Float -> Effect (Msg msg)\nwaitAndCheck millis =\n    Effect.nowAfter millis TimeReceived\n\n\ntype Msg msg\n    = TimeReceived Time.Posix\n    | Start msg Time.Posix\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/File.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/File.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.File exposing (file, files, toUrl)\n\n{-|\n\n@docs file, files, toUrl\n\n-}\n\nimport Effect\nimport File\n\n\n{-| -}\nfile : List String -> (File.File -> msg) -> Effect.Effect msg\nfile =\n    Effect.File\n\n\nfiles : List String -> (File.File -> List File.File -> msg) -> Effect.Effect msg\nfiles =\n    Effect.Files\n\n\ntoUrl : File.File -> (String -> msg) -> Effect.Effect msg\ntoUrl fileData toMsg =\n    Effect.FileToUrl fileData toMsg\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Focus.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Focus.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Focus exposing (blur, focus, select)\n\n{-| Focus a text input and select the text.\n-}\n\nimport Browser.Dom\nimport Effect\nimport Json.Encode as Json\n\n\n{-| Attempt to change the browser focus to the element with a given id.\n-}\nfocus : String -> (Result Browser.Dom.Error () -> msg) -> Effect.Effect msg\nfocus =\n    Effect.Focus\n\n\n{-| Make a specific element lose focus.\n-}\nblur : String -> (Result Browser.Dom.Error () -> msg) -> Effect.Effect msg\nblur =\n    Effect.Blur\n\n\nport textSelection : Json.Value -> Cmd msg\n\n\n{-| Give the id of the text element you want to focus and select the contents of.\n-}\nselect : String -> Effect.Effect msg\nselect id =\n    Effect.SendToWorld\n        { toPort = textSelection\n        , portName = \"textSelection\"\n        , payload =\n            Json.object [ ( \"id\", Json.string id ) ]\n        }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Http.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Http.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Http exposing\n    ( get, request\n    , expectString, expectJson, expectBytes, expectWhatever\n    )\n\n{-|\n\n\n# Http\n\n@docs get, request\n\n@docs Expect, expectString, expectJson, expectBytes, expectWhatever\n\n-}\n\nimport Bytes.Decode\nimport Effect\nimport Http\nimport Json.Decode\n\n\ntype alias Expect msg =\n    Effect.Expect\n\n\nget : String -> Expect msg -> Effect msg\nget url expect =\n    request\n        { method = \"GET\"\n        , headers = []\n        , url = url\n        , target = Nothing\n        , body = Http.emptyBody\n        , expect = expect\n        , timeout = Nothing\n        , tracker = Nothing\n        }\n\n\nrequest :\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , target : Maybe Effect.HttpTarget\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n    -> Effect msg\nrequest options =\n    HttpRequest options\n\n\nexpectString : (Result Http.Error String -> msg) -> Expect msg\nexpectString =\n    ExpectString\n\n\nexpectJson : Json.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectJson =\n    ExpectJson\n\n\nexpectBytes : Bytes.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectBytes =\n    ExpectBytes\n\n\nexpectWhatever : (Result Http.Error () -> msg) -> Expect msg\nexpectWhatever =\n    ExpectWhatever\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/LocalStorage.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/LocalStorage.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.LocalStorage exposing (clear, save)\n\n{-| -}\n\nimport Effect\nimport Json.Encode as Json\n\n\nport localStorage : Json.Encode.Value -> Cmd msg\n\n\n{-| -}\nsave : String -> Json.Value -> Effect.Effect msg\nsave key value =\n    send \"save\"\n        (Json.object\n            [ ( \"key\", Json.string key )\n            , ( \"value\", value )\n            ]\n        )\n\n\n{-| -}\nclear : String -> Effect.Effect msg\nclear key =\n    send \"clear\"\n        (Json.object\n            [ ( \"key\", Json.string key )\n            ]\n        )\n\n\nsend : String -> Json.Value -> Effect.Effect msg\nsend operation value =\n    Effect.SendToWorld\n        { toPort = localStorage\n        , portName = \"local-storage\"\n        , payload =\n            Json.object\n                [ ( \"operation\", Json.string operation )\n                , ( \"details\", value )\n                ]\n        }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Nav.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Nav.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Nav exposing\n    ( toRoute\n    , load, reload, reloadAndSkipCache\n    , forward, back\n    , toUrl, pushUrl, replaceUrl\n    )\n\n{-|\n\n\n# Navigation\n\nThis package mirrors everything in <https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation>\n\nBut also adds `toRoute` which is like `pushUrl` but with your Route type.\n\n@docs toRoute\n\n@docs load, reload, reloadAndSkipCache\n\n@docs forward, back\n\n@docs toUrl, pushUrl, replaceUrl\n\n-}\n\nimport App.Page.Id\nimport App.Route\nimport App.View.Id\nimport Effect exposing (Effect)\nimport Url\n\n\n{-| The default way to navigate between routes within your app.\n\nThis will change the URL, add a new entry to the browser history, but not reload the page.\n\n-}\ntoRoute : App.Route.Route -> Effect msg\ntoRoute route =\n    Effect.PushUrl (App.Route.toString route)\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis will add a new entry to the browser history.\n\n-}\npushUrl : String -> Effect msg\npushUrl =\n    Effect.PushUrl\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis will _not_ add a new entry to the browser history.\n\n-}\nreplaceUrl : String -> Effect msg\nreplaceUrl =\n    Effect.ReplaceUrl\n\n\n{-| -}\nforward : Int -> Effect msg\nforward =\n    Effect.Forward\n\n\n{-| -}\nback : Int -> Effect msg\nback =\n    Effect.Back\n\n\n{-| -}\nload : String -> Effect msg\nload =\n    Effect.Load\n\n\n{-| -}\nreload : Effect msg\nreload =\n    Effect.Reload\n\n\n{-| -}\nreloadAndSkipCache : Effect msg\nreloadAndSkipCache =\n    Effect.ReloadAndSkipCache\n\n\n{-| -}\ntoUrl : Url.Url -> Effect msg\ntoUrl url =\n    case App.Route.parse url of\n        Nothing ->\n            Effect.none\n\n        Just { isRedirect, route } ->\n            if isRedirect then\n                Effect.ReplaceUrl (App.Route.toString route)\n\n            else\n                case App.Page.Id.fromRoute route of\n                    Nothing ->\n                        Effect.none\n\n                    Just pageId ->\n                        Effect.ViewUpdated (App.View.Id.Push App.View.Id.Primary pageId)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Page.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Page.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Page exposing\n    ( preload\n    , loadAt, clear\n    )\n\n{-|\n\n@docs preload\n\n@docs loadAt, clear\n\n-}\n\nimport App.View.Id\nimport Effect exposing (Effect)\n\n\n{-| -}\npreload : App.Page.Id.Id -> Effect msg\npreload =\n    Preload\n\n\n{-| -}\nloadAt : App.View.Id.Region -> App.Page.Id.Id -> Effect msg\nloadAt region pageId =\n    ViewUpdated (App.View.Id.Push region pageId)\n\n\n{-| -}\nclear : App.View.Id.Region -> Effect msg\nclear region =\n    ViewUpdated (App.View.Id.ClearRegion region)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect/Random.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect/Random.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect.Random exposing (generate)\n\nimport Effect\nimport Random\n\n\n{-| Run a random generator to produce a value.\n-}\ngenerate : (item -> msg) -> Random.Generator item -> Effect.Effect msg\ngenerate fn generator =\n    Effect.Generate (Random.map fn generator)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Listen/LocalStorage.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Listen/LocalStorage.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Sub.LocalStorage exposing (..)\n\nimport Json.Decode\nimport Json.Encode\nimport Platform.Sub\nimport Sub\n\n\nport localStorageUpdated : (Json.Encode.Value -> msg) -> Platform.Sub.Sub msg\n\n\nonUpdated :\n    { key : String\n    , decoder : Json.Decode.Decoder msg\n    }\n    -> Sub.Sub msg\nonUpdated options =\n    Sub.OnFromJs\n        { portName = \"localStorageUpdated\"\n        , subscription =\n            localStorageUpdated\n                (Json.Decode.decodeValue options.decoder)\n        }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/WebComponent/Portal.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/WebComponent/Portal.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module WebComponent.Portal exposing\n    ( Model, closed\n    , view\n    , MenuPosition(..)\n    , isOpen\n    , Element, Window\n    )\n\n{-| This custom element is helping us with 2 things.\n\nFirst, we need to be able to render dropdown menus at the top of the DOM so they don't accidently get clipped when there are scrollbars.\n\nThe scrollbar clipping thing is a hard blocker from how CSS and stacking contexts work, so our solution is to render it in one place in\nthe DOM in Elm, but have some javascript that moves the element to a place at the top of the DOM behind the scenes.\n\nThis is called a \"portal\" in React land. So, we're just copying that here.\n\nSecond! We also want a drop down to be a drop _up_ if it is too low on the screen. We can do this calculation by capturing bounding boxes and doing some math with the window.\n\nThis element does not care about other styling or behavior though!\n\n@docs Model, closed\n@docs view\n\n@docs MenuPosition\n@docs isOpen\n@docs Element, Window\n\n-}\n\nimport Html exposing (Html)\nimport Html.Attributes as Attr\nimport Html.Events\nimport Json.Decode\n\n\ntype Model\n    = Open Viewport\n    | Closed\n\n\nclosed : Model\nclosed =\n    Closed\n\n\nisOpen : Model -> Bool\nisOpen model =\n    model /= Closed\n\n\ntype alias Viewport =\n    { parent : Element\n    , window : Window\n    }\n\n\ntype alias Element =\n    { x : Float\n    , y : Float\n    , width : Float\n    , height : Float\n    }\n\n\ntype alias Window =\n    { width : Float\n    , height : Float\n    }\n\n\nonToggle :\n    { options\n        | model : Model\n        , onMsg : Model -> msg\n    }\n    -> Html.Attribute msg\nonToggle { model, onMsg } =\n    Html.Events.on \"click\"\n        (Json.Decode.map2\n            (\\parent window ->\n                case model of\n                    Closed ->\n                        onMsg\n                            (Open\n                                { parent = parent\n                                , window = window\n                                }\n                            )\n\n                    Open _ ->\n                        onMsg Closed\n            )\n            (Json.Decode.at [ \"currentTarget\", \"__getParentClientRect\" ] elementDecoder)\n            (Json.Decode.at [ \"currentTarget\", \"__getWindowSize\" ] windowDecode)\n        )\n\n\nwindowDecode : Json.Decode.Decoder Window\nwindowDecode =\n    Json.Decode.map2 Window\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nelementDecoder : Json.Decode.Decoder Element\nelementDecoder =\n    Json.Decode.map4 Element\n        (Json.Decode.field \"x\" Json.Decode.float)\n        (Json.Decode.field \"y\" Json.Decode.float)\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nview :\n    { position : MenuPosition\n    , model : Model\n    , onMsg : Model -> msg\n    , button : Html msg\n    , menu : Html msg\n    }\n    -> Html msg\nview options =\n    let\n        dismissMenuOnEscapeEvent =\n            Html.Events.on \"keyup\"\n                (Json.Decode.field \"key\" Json.Decode.string\n                    |> Json.Decode.andThen\n                        (\\key ->\n                            if key == \"Escape\" then\n                                Json.Decode.succeed (options.onMsg Closed)\n\n                            else\n                                Json.Decode.fail key\n                        )\n                )\n\n        viewMenu : Viewport -> Html msg\n        viewMenu viewport =\n            Html.div\n                [ Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" (px viewport.parent.y)\n                , Attr.style \"left\" (px viewport.parent.x)\n                , Attr.style \"width\" (px viewport.parent.width)\n                , Attr.style \"height\" (px viewport.parent.height)\n                , dismissMenuOnEscapeEvent\n                ]\n                [ Html.div\n                    [ Html.Events.onClick (options.onMsg Closed)\n                    , Attr.style \"position\" \"absolute\"\n                    , Attr.style \"top\" \"0\"\n                    , Attr.style \"left\" \"0\"\n                    , Attr.style \"right\" \"0\"\n                    , Attr.style \"bottom\" \"0\"\n                    ]\n                    []\n                , Html.div\n                    (toPositionAttributes\n                        { position = options.position\n                        , viewport = viewport\n                        }\n                    )\n                    [ options.menu ]\n                ]\n\n        viewDismissOverlay : Html msg\n        viewDismissOverlay =\n            Html.div\n                [ Html.Events.onClick (options.onMsg Closed)\n                , Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" \"0\"\n                , Attr.style \"left\" \"0\"\n                , Attr.style \"width\" \"100%\"\n                , Attr.style \"height\" \"100%\"\n                ]\n                []\n    in\n    Html.div []\n        [ Html.div [ onToggle options ] [ options.button ]\n        , case options.model of\n            Open viewport ->\n                Html.node \"elm-portal\"\n                    []\n                    [ viewDismissOverlay\n                    , viewMenu viewport\n                    ]\n\n            Closed ->\n                Html.text \"\"\n        ]\n\n\ntype MenuPosition\n    = -- Render below toggle button\n      Below { isAlignedLeft : Bool }\n      -- Render to the right of the toggle button\n    | ToRightOf\n\n\ntoPositionAttributes :\n    { position : MenuPosition, viewport : Viewport }\n    -> List (Html.Attribute msg)\ntoPositionAttributes { position, viewport } =\n    let\n        menuBelowRightAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"right\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuBelowLeftAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"left\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightTopAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"top\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightBottomAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"bottom\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        attemptToAlignLeft =\n            if viewport.window.width - viewport.parent.x < 400 then\n                menuBelowRightAligned\n\n            else\n                menuBelowLeftAligned\n\n        attemptToAlignRight =\n            if viewport.parent.x < 400 then\n                menuBelowLeftAligned\n\n            else\n                menuBelowRightAligned\n    in\n    case position of\n        Below { isAlignedLeft } ->\n            if isAlignedLeft then\n                attemptToAlignLeft\n\n            else\n                attemptToAlignRight\n\n        ToRightOf ->\n            if viewport.window.height - viewport.parent.y < 400 then\n                menuOnRightBottomAligned\n\n            else\n                menuOnRightTopAligned\n\n\npx : Float -> String\npx float =\n    String.fromFloat float ++ \"px\"\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Broadcast.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Broadcast.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Broadcast exposing (Msg(..))\n\n{-| This is a module that is special for elm-prefab.\n\nThe `Msg` here can be broadcasted globally to any page that is listening.\n\nTo broadcast a message, you'd do this in your `update` function:\n\n    Effect.broadcast Broadcast.LogOut\n\nAnd to listen for this message, in your subscriptions, you'd have\n\n    Listen.broadcast\n        (\\broadcastMsg ->\n            case broadcastMsg of\n                Broadcast.LogOut ->\n                    -- You can choose which messages you opt in to.\n                    Nothing\n        )\n\n-}\n\n\ntype Msg\n    = LogOut\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Effect.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Effect.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Effect exposing\n    ( Effect(..), none, batch, map\n    , now, nowAfter\n    , sendMsg, sendMsgAfter\n    , Expect(..), HttpTarget(..)\n    , toCmd\n    )\n\n{-|\n\n@docs Effect, none, batch, map\n\n\n# Time\n\n@docs now, nowAfter\n\n\n# Callbacks\n\n@docs sendMsg, sendMsgAfter\n\n\n# Internal Http Details\n\n@docs Expect, HttpTarget\n\n\n# Effects\n\n@docs toCmd\n\n-}\n\nimport App.Page.Id\nimport App.View.Id\nimport Broadcast\nimport Browser.Dom\nimport Browser.Navigation\nimport Bytes.Decode\nimport File\nimport File.Select\nimport Http\nimport Json.Decode\nimport Json.Encode\nimport Process\nimport Random\nimport Task\nimport Time\n\n\nnone : Effect msg\nnone =\n    None\n\n\nbatch : List (Effect msg) -> Effect msg\nbatch =\n    Batch\n\n\nsendMsg : msg -> Effect msg\nsendMsg =\n    SendMsg\n\n\nsendMsgAfter : Int -> msg -> Effect msg\nsendMsgAfter delay msg =\n    SendMsgAfter delay msg\n\n\n{-| Get the current time\n-}\nnow : (Time.Posix -> msg) -> Effect msg\nnow =\n    Now Nothing\n\n\n{-| Delay for some number of milliseconds, then get the current time\n-}\nnowAfter : Float -> (Time.Posix -> msg) -> Effect msg\nnowAfter wait =\n    Now (Just wait)\n\n\ntype Effect msg\n    = None\n    | Batch (List (Effect msg))\n      --\n    | SendMsg msg\n    | SendMsgAfter Int msg\n      -- Random generation\n    | Generate (Random.Generator msg)\n      -- Time\n    | Now (Maybe Float) (Time.Posix -> msg)\n      -- Focus/Blur\n    | Focus String (Result Browser.Dom.Error () -> msg)\n    | Blur String (Result Browser.Dom.Error () -> msg)\n      -- Urls\n    | PushUrl String\n    | ReplaceUrl String\n      -- Files\n    | File (List String) (File.File -> msg)\n    | Files (List String) (File.File -> List File.File -> msg)\n    | FileToUrl File.File (String -> msg)\n      -- Loading\n    | ViewUpdated (App.View.Id.Operation App.Page.Id.Id)\n      -- Browser Navigation\n    | Preload App.Page.Id.Id\n    | Load String\n    | Reload\n    | ReloadAndSkipCache\n      -- History navigation\n    | Forward Int\n    | Back Int\n      -- Http\n    | HttpRequest (RequestDetails msg)\n    | SendBroadcast Broadcast.Msg\n      -- JS interop\n    | SendToWorld\n        { toPort : Json.Encode.Value -> Cmd msg\n        , portName : String\n        , payload : Json.Encode.Value\n        }\n\n\ntype alias RequestDetails msg =\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , expect : Expect msg\n    , target : Maybe HttpTarget\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n\n\n{-| This type is here if you want to do something like include special headers for your API\n\nOr switch out urls depending on how the app is configured.\n\n-}\ntype HttpTarget\n    = TargetApi\n    | TargetStaticFile\n    | TargetExternal String\n\n\ntype Expect msg\n    = ExpectString (Result Http.Error String -> msg)\n    | ExpectJson (Json.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectBytes (Bytes.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectWhatever (Result Http.Error () -> msg)\n\n\ntoCmd :\n    { navKey : Browser.Navigation.Key\n    , preload : App.Page.Id.Id -> msg\n    , dropPageCache : msg\n    , viewRequested : App.View.Id.Operation App.Page.Id.Id -> msg\n    , broadcast : Broadcast.Msg -> msg\n    }\n    ->\n        (HttpTarget\n         ->\n            { headers : List Http.Header\n            , urlBase : String\n            }\n        )\n    -> Effect msg\n    -> Cmd msg\ntoCmd options toHttpTarget effect =\n    case effect of\n        None ->\n            Cmd.none\n\n        Batch effects ->\n            Cmd.batch (List.map (toCmd options toHttpTarget) effects)\n\n        Generate generator ->\n            Random.generate identity generator\n\n        Now Nothing toMsg ->\n            Time.now\n                |> Task.perform toMsg\n\n        Now (Just wait) toMsg ->\n            Process.sleep wait\n                |> Task.andThen\n                    (\\_ -> Time.now)\n                |> Task.perform toMsg\n\n        Focus id toMsg ->\n            Process.sleep 1\n                |> Task.andThen\n                    (\\_ -> Browser.Dom.focus id)\n                |> Task.attempt toMsg\n\n        Blur id toMsg ->\n            Browser.Dom.blur id\n                |> Task.attempt toMsg\n\n        PushUrl url ->\n            Browser.Navigation.pushUrl options.navKey url\n\n        ReplaceUrl url ->\n            Browser.Navigation.replaceUrl options.navKey url\n\n        ViewUpdated op ->\n            Task.succeed ()\n                |> Task.perform\n                    (\\_ ->\n                        options.viewRequested op\n                    )\n\n        Load url ->\n            Browser.Navigation.load url\n\n        Reload ->\n            Browser.Navigation.reload\n\n        ReloadAndSkipCache ->\n            Browser.Navigation.reloadAndSkipCache\n\n        Forward steps ->\n            Browser.Navigation.forward options.navKey steps\n\n        Back steps ->\n            Browser.Navigation.back options.navKey steps\n\n        SendToWorld { toPort, payload } ->\n            toPort payload\n\n        SendBroadcast msg ->\n            Task.succeed msg\n                |> Task.perform options.broadcast\n\n        SendMsg msg ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> msg)\n\n        SendMsgAfter delay msg ->\n            Process.sleep (toFloat delay)\n                |> Task.map (\\_ -> msg)\n                |> Task.perform identity\n\n        Preload pageId ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> options.preload pageId)\n\n        File extensions toMsg ->\n            File.Select.file extensions toMsg\n\n        Files extensions toMsg ->\n            File.Select.files extensions toMsg\n\n        FileToUrl fileData toMsg ->\n            File.toUrl fileData\n                |> Task.perform toMsg\n\n        HttpRequest req ->\n            let\n                targetDetails =\n                    case req.target of\n                        Just target ->\n                            toHttpTarget target\n\n                        Nothing ->\n                            { headers = []\n                            , urlBase = \"\"\n                            }\n            in\n            Http.request\n                { method = req.method\n                , body = req.body\n                , url = joinPath targetDetails.urlBase req.url\n                , headers = req.headers ++ targetDetails.headers\n                , expect = toHttpExpect req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n\njoinPath : String -> String -> String\njoinPath base path =\n    let\n        baseSlash =\n            String.endsWith \"/\" base\n\n        pathSlash =\n            String.startsWith \"/\" path\n    in\n    if baseSlash && pathSlash then\n        base ++ String.dropLeft 1 path\n\n    else if baseSlash || pathSlash then\n        base ++ path\n\n    else\n        base ++ \"/\" ++ path\n\n\nmap : (a -> b) -> Effect a -> Effect b\nmap f effect =\n    case effect of\n        None ->\n            None\n\n        Batch effects ->\n            Batch (List.map (map f) effects)\n\n        PushUrl url ->\n            PushUrl url\n\n        ReplaceUrl url ->\n            ReplaceUrl url\n\n        ViewUpdated op ->\n            ViewUpdated op\n\n        Load url ->\n            Load url\n\n        Reload ->\n            Reload\n\n        ReloadAndSkipCache ->\n            ReloadAndSkipCache\n\n        Forward n ->\n            Forward n\n\n        Back n ->\n            Back n\n\n        SendToWorld { toPort, portName, payload } ->\n            SendToWorld\n                { toPort = \\val -> Cmd.map f (toPort val)\n                , portName = portName\n                , payload = payload\n                }\n\n        SendBroadcast msg ->\n            SendBroadcast msg\n\n        SendMsg msg ->\n            SendMsg (f msg)\n\n        SendMsgAfter delay msg ->\n            SendMsgAfter delay (f msg)\n\n        Focus id msg ->\n            Focus id (msg >> f)\n\n        Blur id msg ->\n            Blur id (msg >> f)\n\n        Preload route ->\n            Preload route\n\n        HttpRequest req ->\n            HttpRequest\n                { method = req.method\n                , headers = req.headers\n                , target = req.target\n                , url = req.url\n                , body = req.body\n                , expect = mapExpect f req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n        File extensions toMsg ->\n            File extensions (toMsg >> f)\n\n        Files extensions toMsg ->\n            Files extensions (\\top remaining -> toMsg top remaining |> f)\n\n        FileToUrl fileData toMsg ->\n            FileToUrl fileData (toMsg >> f)\n\n        Now maybeWait toMsg ->\n            Now maybeWait (toMsg >> f)\n\n        Generate generator ->\n            Generate (Random.map f generator)\n\n\ntoHttpExpect : Expect msg -> Http.Expect msg\ntoHttpExpect expect =\n    case expect of\n        ExpectString toMsg ->\n            Http.expectString toMsg\n\n        ExpectJson decoder onError ->\n            Http.expectJson\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectBytes decoder onError ->\n            Http.expectBytes\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectWhatever toMsg ->\n            Http.expectWhatever toMsg\n\n\nmapExpect : (a -> b) -> Expect a -> Expect b\nmapExpect fn expect =\n    case expect of\n        ExpectString toMsg ->\n            ExpectString (toMsg >> fn)\n\n        ExpectJson decoder onError ->\n            ExpectJson (Json.Decode.map fn decoder) (onError >> fn)\n\n        ExpectBytes decoder onError ->\n            ExpectBytes (Bytes.Decode.map fn decoder) (onError >> fn)\n\n        ExpectWhatever toMsg ->\n            ExpectWhatever (toMsg >> fn)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Listen.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Listen.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Listen exposing\n    ( Listen(..)\n    , none, batch\n    , onKeyPress\n    , onEvery\n    , onResize\n    , map, toSubscription\n    , broadcastListeners\n    )\n\n{-|\n\n\n# Listeners\n\n@docs Listen\n\n@docs none, batch\n\n@docs onKeyPress\n\n@docs onEvery\n\n@docs onResize\n\n@docs map, toSubscription\n\n@docs broadcastListeners\n\n-}\n\nimport Broadcast\nimport Browser.Events\nimport Json.Decode\nimport Platform.Sub\nimport Time\n\n\ntype Listen msg\n    = None\n    | Batch (List (Listen msg))\n      -- Common subscriptions\n    | Every Float (Time.Posix -> msg)\n    | OnWindowResize (Int -> Int -> msg)\n    | OnKeyPress\n        { ctrl : Bool\n        , shift : Bool\n        , key : String\n        }\n        msg\n    | OnBroadcast (Broadcast.Msg -> Maybe msg)\n      --\n    | OnFromJs\n        { portName : String\n        , subscription : Platform.Sub.Sub (Result Json.Decode.Error msg)\n        }\n\n\n{-| -}\nnone : Listen msg\nnone =\n    None\n\n\n{-| -}\nbatch : List (Listen msg) -> Listen msg\nbatch =\n    Batch\n\n\n{-| -}\nonKeyPress : { ctrl : Bool, shift : Bool, key : String } -> msg -> Listen msg\nonKeyPress options msg =\n    OnKeyPress options msg\n\n\n{-| -}\nonEvery : Float -> (Time.Posix -> msg) -> Listen msg\nonEvery ms toMsg =\n    Every ms toMsg\n\n\n{-| -}\nonResize : (Int -> Int -> msg) -> Listen msg\nonResize msg =\n    OnWindowResize msg\n\n\n{-| -}\nmap : (a -> b) -> Listen a -> Listen b\nmap func sub =\n    case sub of\n        None ->\n            None\n\n        Batch subs ->\n            Batch (List.map (map func) subs)\n\n        Every ms toMsg ->\n            Every ms (func << toMsg)\n\n        OnKeyPress options msg ->\n            OnKeyPress options (func msg)\n\n        OnWindowResize msg ->\n            OnWindowResize (\\w h -> func <| msg w h)\n\n        OnBroadcast toMsg ->\n            OnBroadcast (Maybe.map func << toMsg)\n\n        OnFromJs fromJs ->\n            OnFromJs\n                { portName = fromJs.portName\n                , subscription =\n                    Sub.map (Result.map func) fromJs.subscription\n                }\n\n\n{-| -}\ntoSubscription : { ignore : String -> msg } -> Listen msg -> Platform.Sub.Sub msg\ntoSubscription options sub =\n    case sub of\n        None ->\n            Platform.Sub.none\n\n        Batch subs ->\n            Platform.Sub.batch (List.map (toSubscription options) subs)\n\n        Every ms toMsg ->\n            Time.every ms toMsg\n\n        OnWindowResize toMsg ->\n            Browser.Events.onResize toMsg\n\n        OnKeyPress keyOptions msg ->\n            Browser.Events.onKeyDown\n                (Json.Decode.map4\n                    (\\_ ctrl shift meta ->\n                        { ctrl = ctrl\n                        , shift = shift\n                        , meta = meta\n                        }\n                    )\n                    (Json.Decode.field \"key\" Json.Decode.string\n                        |> Json.Decode.andThen\n                            (\\key ->\n                                if String.toLower key == String.toLower keyOptions.key then\n                                    Json.Decode.succeed True\n\n                                else\n                                    Json.Decode.fail \"Not a match\"\n                            )\n                    )\n                    (Json.Decode.field \"ctrlKey\" Json.Decode.bool)\n                    (Json.Decode.field \"shiftKey\" Json.Decode.bool)\n                    (Json.Decode.field \"metaKey\" Json.Decode.bool)\n                    |> Json.Decode.andThen\n                        (\\event ->\n                            -- accept both \"meta\" (Cmd on macs)\n                            --  and \"ctrl\"\n                            if (keyOptions.ctrl == event.ctrl || keyOptions.ctrl == event.meta) && keyOptions.shift == event.shift then\n                                Json.Decode.succeed msg\n\n                            else\n                                Json.Decode.fail \"Not a match\"\n                        )\n                )\n\n        OnBroadcast toMsg ->\n            -- This isn't handled like a normal subscription\n            -- We use `broadcastListeners` to handle this\n            Sub.none\n\n        OnFromJs fromJs ->\n            fromJs.subscription\n                |> Sub.map\n                    (\\result ->\n                        case result of\n                            Ok success ->\n                                success\n\n                            Err err ->\n                                options.ignore (Json.Decode.errorToString err)\n                    )\n\n\n{-| You shouldn't need to use this directly, it's used by some code that elm-prefab generates.\n-}\nbroadcastListeners : Broadcast.Msg -> Listen msg -> List msg\nbroadcastListeners broadcastMsg sub =\n    case sub of\n        None ->\n            []\n\n        Batch subs ->\n            List.concatMap (broadcastListeners broadcastMsg) subs\n\n        Every _ _ ->\n            []\n\n        OnWindowResize _ ->\n            []\n\n        OnKeyPress _ _ ->\n            []\n\n        OnBroadcast toMsg ->\n            case toMsg broadcastMsg of\n                Just msg ->\n                    [ msg ]\n\n                Nothing ->\n                    []\n\n        OnFromJs _ ->\n            []\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }
}
