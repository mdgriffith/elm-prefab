
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";


export const App_Page_Error = {
   moduleName: "App.Page.Error",
   path: "/App/Page/Error.elm",
   contents: "module App.Page.Error exposing (Error(..))\n\n{-| You may want to protect a page with a certain error when it is first requested.\n\n  - `NotFound` is built in to `elm-prefab`, so you don't need to capture that here.\n\nCommon errors are\n\n    - Unauthenticated — When you require someone to be signed in in order to see a page.\n    - Permission denied — When you require taht someone is both signed in and has certain permissions.\n\n-}\n\n\ntype Error\n    = Unauthenticated\n"
}

export const App_View = {
   moduleName: "App.View",
   path: "/App/View.elm",
   contents: "module App.View exposing\n    ( View, map\n    , Regions, isVisible\n    )\n\n{-|\n\n@docs View, map\n\n@docs Regions, isVisible\n\n-}\n\nimport Html\n\n\ntype alias View msg =\n    { title : String\n    , body : Html.Html msg\n    }\n\n\nmap : (a -> b) -> View a -> View b\nmap fn myView =\n    { title = myView.title\n    , body = Html.map fn myView.body\n    }\n\n\n\n{- Regions -}\n\n\n{-| -}\ntype alias Regions view =\n    { primary : Maybe view\n    , detail : List view\n    }\n\n\n{-| -}\nisVisible : view -> Regions view -> Bool\nisVisible view regions =\n    case regions.primary of\n        Just primaryView ->\n            if view == primaryView then\n                True\n\n            else\n                List.any ((==) view) regions.detail\n\n        Nothing ->\n            List.any ((==) view) regions.detail\n"
}

export const Effect_Clipboard = {
   moduleName: "Effect.Clipboard",
   path: "/Effect/Clipboard.elm",
   contents: "module Effect.Clipboard exposing (copy)\n\n{-| Copy a value to the clipboard\n-}\n\nimport Effect\nimport Json.Encode as Json\n\n\nport clipboard : Json.Value -> Cmd msg\n\n\ncopy : String -> Effect.Effect msg\ncopy text =\n    Effect.SendToWorld\n        { toPort = clipboard\n        , portName = \"clipboard\"\n        , payload =\n            Json.string text\n        }\n"
}

export const Effect_Debounce = {
   moduleName: "Effect.Debounce",
   path: "/Effect/Debounce.elm",
   contents: "module Effect.Debounce exposing\n    ( init, send\n    , update, Model, Msg\n    )\n\n{-|\n\n@docs init, send\n\n@docs update, Model, Msg\n\n-}\n\nimport Effect exposing (Effect)\nimport Time\n\n\nsend : msg -> Model msg -> Effect (Msg msg)\nsend msg (Model model) =\n    case model.state of\n        NothingToSend ->\n            Effect.now (Start msg)\n\n        WaitingToSend _ previouslySent ->\n            if msg == previouslySent then\n                Effect.none\n\n            else\n                Effect.now (Start msg)\n\n\ntype Model msg\n    = Model\n        { state : State msg\n        , delay : Float\n        }\n\n\ntype State msg\n    = NothingToSend\n    | WaitingToSend Time.Posix msg\n\n\ninit : Float -> Model msg\ninit milliseconds =\n    Model\n        { state = NothingToSend\n        , delay = milliseconds\n        }\n\n\nupdate : (Msg msg -> msg) -> Msg msg -> Model msg -> ( Model msg, Effect msg )\nupdate toMsg msg (Model model) =\n    let\n        paddedDelay =\n            model.delay + 10\n    in\n    case msg of\n        Start msgToSend sentAt ->\n            case model.state of\n                NothingToSend ->\n                    ( Model { model | state = WaitingToSend sentAt msgToSend }\n                    , Effect.map toMsg (waitAndCheck paddedDelay)\n                    )\n\n                WaitingToSend _ previousMsg ->\n                    if msgToSend == previousMsg then\n                        ( Model model, Effect.none )\n\n                    else\n                        ( Model { model | state = WaitingToSend sentAt msgToSend }\n                        , Effect.map toMsg (waitAndCheck paddedDelay)\n                        )\n\n        TimeReceived now ->\n            case model.state of\n                NothingToSend ->\n                    ( Model { model | state = NothingToSend }\n                    , Effect.none\n                    )\n\n                WaitingToSend startedAt sendableMsg ->\n                    let\n                        millisSinceStart =\n                            Time.posixToMillis now - Time.posixToMillis startedAt\n                    in\n                    if toFloat millisSinceStart >= model.delay then\n                        ( Model { model | state = NothingToSend }\n                        , Effect.callback sendableMsg\n                        )\n\n                    else\n                        ( Model model\n                        , Effect.map toMsg (waitAndCheck paddedDelay)\n                        )\n\n\nwaitAndCheck : Float -> Effect (Msg msg)\nwaitAndCheck millis =\n    Effect.nowAfter millis TimeReceived\n\n\ntype Msg msg\n    = TimeReceived Time.Posix\n    | Start msg Time.Posix\n"
}

export const Effect_File = {
   moduleName: "Effect.File",
   path: "/Effect/File.elm",
   contents: "module Effect.File exposing (file, files, toUrl)\n\n{-|\n\n@docs file, files, toUrl\n\n-}\n\nimport Effect\nimport File\n\n\n{-| -}\nfile : List String -> (File.File -> msg) -> Effect.Effect msg\nfile =\n    Effect.File\n\n\nfiles : List String -> (File.File -> List File.File -> msg) -> Effect.Effect msg\nfiles =\n    Effect.Files\n\n\ntoUrl : File.File -> (String -> msg) -> Effect.Effect msg\ntoUrl fileData toMsg =\n    Effect.FileToUrl fileData toMsg\n"
}

export const Effect_Focus = {
   moduleName: "Effect.Focus",
   path: "/Effect/Focus.elm",
   contents: "module Effect.Focus exposing (blur, focus, select)\n\n{-| Focus a text input and select the text.\n-}\n\nimport Browser.Dom\nimport Effect\nimport Json.Encode as Json\n\n\n{-| Attempt to change the browser focus to the element with a given id.\n-}\nfocus : String -> (Result Browser.Dom.Error () -> msg) -> Effect.Effect msg\nfocus =\n    Effect.Focus\n\n\n{-| Make a specific element lose focus.\n-}\nblur : String -> (Result Browser.Dom.Error () -> msg) -> Effect.Effect msg\nblur =\n    Effect.Blur\n\n\nport textSelection : Json.Value -> Cmd msg\n\n\n{-| Give the id of the text element you want to focus and select the contents of.\n-}\nselect : String -> Effect.Effect msg\nselect id =\n    Effect.SendToWorld\n        { toPort = textSelection\n        , portName = \"textSelection\"\n        , payload =\n            Json.object [ ( \"id\", Json.string id ) ]\n        }\n"
}

export const Effect_Http = {
   moduleName: "Effect.Http",
   path: "/Effect/Http.elm",
   contents: "module Effect.Http exposing\n    ( get, request\n    , expectString, expectStringResponse, expectJson, expectBytes, expectWhatever\n    )\n\n{-|\n\n\n# Http\n\n@docs get, request\n\n@docs Expect, expectString, expectStringResponse, expectJson, expectBytes, expectWhatever\n\n-}\n\nimport Bytes.Decode\nimport Effect\nimport Http\nimport Json.Decode\n\n\ntype alias Expect msg =\n    Effect.Expect\n\n\nget : String -> Expect msg -> Effect msg\nget url expect =\n    request\n        { method = \"GET\"\n        , headers = []\n        , url = url\n        , urlBase = Nothing\n        , body = Http.emptyBody\n        , expect = expect\n        , timeout = Nothing\n        , tracker = Nothing\n        }\n\n\n{-| This is how to make an HTTP request, but it's kinda low level!\n\nInstead of using it directly, which would be a bit of a pain, make a new module that models the API you're working with.\n\nSo, let's say you're working with the GitHub API.\n\nRun `elm-prefab add effect http Github`.\n\nYou should now have a new module called `Effect.Github` that you can use to make requests to the GitHub API. Bake in as many details as you can to make the API nice!\n\n-}\nrequest :\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , urlBase : Maybe Effect.UrlBase\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n    -> Effect msg\nrequest options =\n    HttpRequest options\n\n\nexpectString : (Result Http.Error String -> msg) -> Expect msg\nexpectString =\n    ExpectString\n\n\n{-| When you need more control over the error handling\n-}\nexpectStringResponse : (Http.Response String -> msg) -> Expect msg\nexpectStringResponse =\n    ExpectStringResponse\n\n\nexpectJson : Json.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectJson =\n    ExpectJson\n\n\nexpectBytes : Bytes.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectBytes =\n    ExpectBytes\n\n\nexpectWhatever : (Result Http.Error () -> msg) -> Expect msg\nexpectWhatever =\n    ExpectWhatever\n"
}

export const Effect_LocalStorage = {
   moduleName: "Effect.LocalStorage",
   path: "/Effect/LocalStorage.elm",
   contents: "module Effect.LocalStorage exposing (clear, save)\n\n{-| -}\n\nimport Effect\nimport Json.Encode as Json\n\n\nport localStorage : Json.Encode.Value -> Cmd msg\n\n\n{-| -}\nsave : String -> Json.Value -> Effect.Effect msg\nsave key value =\n    send \"save\"\n        (Json.object\n            [ ( \"key\", Json.string key )\n            , ( \"value\", value )\n            ]\n        )\n\n\n{-| -}\nclear : String -> Effect.Effect msg\nclear key =\n    send \"clear\"\n        (Json.object\n            [ ( \"key\", Json.string key )\n            ]\n        )\n\n\nsend : String -> Json.Value -> Effect.Effect msg\nsend operation value =\n    Effect.SendToWorld\n        { toPort = localStorage\n        , portName = \"local-storage\"\n        , payload =\n            Json.object\n                [ ( \"operation\", Json.string operation )\n                , ( \"details\", value )\n                ]\n        }\n"
}

export const Effect_Nav = {
   moduleName: "Effect.Nav",
   path: "/Effect/Nav.elm",
   contents: "module Effect.Nav exposing\n    ( toRoute\n    , load, reload, reloadAndSkipCache\n    , forward, back\n    , toUrl, pushUrl, replaceUrl\n    )\n\n{-|\n\n\n# Navigation\n\nThis package mirrors everything in <https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation>\n\nBut also adds `toRoute` which is like `pushUrl` but with your Route type.\n\n@docs toRoute\n\n@docs load, reload, reloadAndSkipCache\n\n@docs forward, back\n\n@docs toUrl, pushUrl, replaceUrl\n\n-}\n\nimport App.Page.Id\nimport App.Route\nimport App.View.Id\nimport Effect exposing (Effect)\nimport Url\n\n\n{-| The default way to navigate between routes within your app.\n\nThis will change the URL, add a new entry to the browser history, but not reload the page.\n\n-}\ntoRoute : App.Route.Route -> Effect msg\ntoRoute route =\n    Effect.PushUrl (App.Route.toString route)\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis will add a new entry to the browser history.\n\n-}\npushUrl : String -> Effect msg\npushUrl =\n    Effect.PushUrl\n\n\n{-| Change the URL, but do not trigger a page load.\n\nThis will _not_ add a new entry to the browser history.\n\n-}\nreplaceUrl : String -> Effect msg\nreplaceUrl =\n    Effect.ReplaceUrl\n\n\n{-| -}\nforward : Int -> Effect msg\nforward =\n    Effect.Forward\n\n\n{-| -}\nback : Int -> Effect msg\nback =\n    Effect.Back\n\n\n{-| -}\nload : String -> Effect msg\nload =\n    Effect.Load\n\n\n{-| -}\nreload : Effect msg\nreload =\n    Effect.Reload\n\n\n{-| -}\nreloadAndSkipCache : Effect msg\nreloadAndSkipCache =\n    Effect.ReloadAndSkipCache\n\n\n{-| -}\ntoUrl : Url.Url -> Effect msg\ntoUrl url =\n    case App.Route.parse url of\n        Nothing ->\n            Effect.none\n\n        Just { isRedirect, route } ->\n            if isRedirect then\n                Effect.ReplaceUrl (App.Route.toString route)\n\n            else\n                case App.Page.Id.fromRoute route of\n                    Nothing ->\n                        Effect.none\n\n                    Just pageId ->\n                        Effect.ViewUpdated (App.View.Id.Push App.View.Id.Primary pageId)\n"
}

export const Effect_Page = {
   moduleName: "Effect.Page",
   path: "/Effect/Page.elm",
   contents: "module Effect.Page exposing\n    ( preload\n    , loadAt, clear\n    )\n\n{-|\n\n@docs preload\n\n@docs loadAt, clear\n\n-}\n\nimport App.View.Id\nimport Effect exposing (Effect)\n\n\n{-| -}\npreload : App.Page.Id.Id -> Effect msg\npreload =\n    Preload\n\n\n{-| -}\nloadAt : App.View.Id.Region -> App.Page.Id.Id -> Effect msg\nloadAt region pageId =\n    ViewUpdated (App.View.Id.Push region pageId)\n\n\n{-| -}\nclear : App.View.Id.Region -> Effect msg\nclear region =\n    ViewUpdated (App.View.Id.ClearRegion region)\n"
}

export const Effect_Random = {
   moduleName: "Effect.Random",
   path: "/Effect/Random.elm",
   contents: "module Effect.Random exposing (generate)\n\nimport Effect\nimport Random\n\n\n{-| Run a random generator to produce a value.\n-}\ngenerate : (item -> msg) -> Random.Generator item -> Effect.Effect msg\ngenerate fn generator =\n    Effect.Generate (Random.map fn generator)\n"
}

export const Listen_LocalStorage = {
   moduleName: "Listen.LocalStorage",
   path: "/Listen/LocalStorage.elm",
   contents: "module Listen.LocalStorage exposing (..)\n\nimport Json.Decode\nimport Json.Encode\nimport Platform.Sub\nimport Sub\n\n\nport localStorageUpdated : (Json.Encode.Value -> msg) -> Platform.Sub.Sub msg\n\n\nonUpdated :\n    { key : String\n    , decoder : Json.Decode.Decoder msg\n    }\n    -> Sub.Sub msg\nonUpdated options =\n    Sub.OnFromJs\n        { portName = \"localStorageUpdated\"\n        , subscription =\n            localStorageUpdated\n                (Json.Decode.decodeValue options.decoder)\n        }\n"
}

export const WebComponent_Portal = {
   moduleName: "WebComponent.Portal",
   path: "/WebComponent/Portal.elm",
   contents: "module WebComponent.Portal exposing\n    ( Model, closed\n    , view\n    , MenuPosition(..)\n    , isOpen\n    , Element, Window\n    )\n\n{-| This custom element is helping us with 2 things.\n\nFirst, we need to be able to render dropdown menus at the top of the DOM so they don't accidently get clipped when there are scrollbars.\n\nThe scrollbar clipping thing is a hard blocker from how CSS and stacking contexts work, so our solution is to render it in one place in\nthe DOM in Elm, but have some javascript that moves the element to a place at the top of the DOM behind the scenes.\n\nThis is called a \"portal\" in React land. So, we're just copying that here.\n\nSecond! We also want a drop down to be a drop _up_ if it is too low on the screen. We can do this calculation by capturing bounding boxes and doing some math with the window.\n\nThis element does not care about other styling or behavior though!\n\n@docs Model, closed\n@docs view\n\n@docs MenuPosition\n@docs isOpen\n@docs Element, Window\n\n-}\n\nimport Html exposing (Html)\nimport Html.Attributes as Attr\nimport Html.Events\nimport Json.Decode\n\n\ntype Model\n    = Open Viewport\n    | Closed\n\n\nclosed : Model\nclosed =\n    Closed\n\n\nisOpen : Model -> Bool\nisOpen model =\n    model /= Closed\n\n\ntype alias Viewport =\n    { parent : Element\n    , window : Window\n    }\n\n\ntype alias Element =\n    { x : Float\n    , y : Float\n    , width : Float\n    , height : Float\n    }\n\n\ntype alias Window =\n    { width : Float\n    , height : Float\n    }\n\n\nonToggle :\n    { options\n        | model : Model\n        , onMsg : Model -> msg\n    }\n    -> Html.Attribute msg\nonToggle { model, onMsg } =\n    Html.Events.on \"click\"\n        (Json.Decode.map2\n            (\\parent window ->\n                case model of\n                    Closed ->\n                        onMsg\n                            (Open\n                                { parent = parent\n                                , window = window\n                                }\n                            )\n\n                    Open _ ->\n                        onMsg Closed\n            )\n            (Json.Decode.at [ \"currentTarget\", \"__getParentClientRect\" ] elementDecoder)\n            (Json.Decode.at [ \"currentTarget\", \"__getWindowSize\" ] windowDecode)\n        )\n\n\nwindowDecode : Json.Decode.Decoder Window\nwindowDecode =\n    Json.Decode.map2 Window\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nelementDecoder : Json.Decode.Decoder Element\nelementDecoder =\n    Json.Decode.map4 Element\n        (Json.Decode.field \"x\" Json.Decode.float)\n        (Json.Decode.field \"y\" Json.Decode.float)\n        (Json.Decode.field \"width\" Json.Decode.float)\n        (Json.Decode.field \"height\" Json.Decode.float)\n\n\nview :\n    { position : MenuPosition\n    , model : Model\n    , onMsg : Model -> msg\n    , button : Html msg\n    , menu : Html msg\n    }\n    -> Html msg\nview options =\n    let\n        dismissMenuOnEscapeEvent =\n            Html.Events.on \"keyup\"\n                (Json.Decode.field \"key\" Json.Decode.string\n                    |> Json.Decode.andThen\n                        (\\key ->\n                            if key == \"Escape\" then\n                                Json.Decode.succeed (options.onMsg Closed)\n\n                            else\n                                Json.Decode.fail key\n                        )\n                )\n\n        viewMenu : Viewport -> Html msg\n        viewMenu viewport =\n            Html.div\n                [ Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" (px viewport.parent.y)\n                , Attr.style \"left\" (px viewport.parent.x)\n                , Attr.style \"width\" (px viewport.parent.width)\n                , Attr.style \"height\" (px viewport.parent.height)\n                , dismissMenuOnEscapeEvent\n                ]\n                [ Html.div\n                    [ Html.Events.onClick (options.onMsg Closed)\n                    , Attr.style \"position\" \"absolute\"\n                    , Attr.style \"top\" \"0\"\n                    , Attr.style \"left\" \"0\"\n                    , Attr.style \"right\" \"0\"\n                    , Attr.style \"bottom\" \"0\"\n                    ]\n                    []\n                , Html.div\n                    (toPositionAttributes\n                        { position = options.position\n                        , viewport = viewport\n                        }\n                    )\n                    [ options.menu ]\n                ]\n\n        viewDismissOverlay : Html msg\n        viewDismissOverlay =\n            Html.div\n                [ Html.Events.onClick (options.onMsg Closed)\n                , Attr.style \"position\" \"fixed\"\n                , Attr.style \"top\" \"0\"\n                , Attr.style \"left\" \"0\"\n                , Attr.style \"width\" \"100%\"\n                , Attr.style \"height\" \"100%\"\n                ]\n                []\n    in\n    Html.div []\n        [ Html.div [ onToggle options ] [ options.button ]\n        , case options.model of\n            Open viewport ->\n                Html.node \"elm-portal\"\n                    []\n                    [ viewDismissOverlay\n                    , viewMenu viewport\n                    ]\n\n            Closed ->\n                Html.text \"\"\n        ]\n\n\ntype MenuPosition\n    = -- Render below toggle button\n      Below { isAlignedLeft : Bool }\n      -- Render to the right of the toggle button\n    | ToRightOf\n\n\ntoPositionAttributes :\n    { position : MenuPosition, viewport : Viewport }\n    -> List (Html.Attribute msg)\ntoPositionAttributes { position, viewport } =\n    let\n        menuBelowRightAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"right\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuBelowLeftAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"top\" \"calc(100% + 4px)\"\n            , Attr.style \"left\" \"0\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightTopAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"top\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        menuOnRightBottomAligned =\n            [ Attr.style \"position\" \"absolute\"\n            , Attr.style \"left\" \"calc(100% + 5px)\"\n            , Attr.style \"bottom\" \"0px\"\n            , Attr.style \"transform\" \"none\"\n            , Attr.style \"min-width\" \"max-content\"\n            ]\n\n        attemptToAlignLeft =\n            if viewport.window.width - viewport.parent.x < 400 then\n                menuBelowRightAligned\n\n            else\n                menuBelowLeftAligned\n\n        attemptToAlignRight =\n            if viewport.parent.x < 400 then\n                menuBelowLeftAligned\n\n            else\n                menuBelowRightAligned\n    in\n    case position of\n        Below { isAlignedLeft } ->\n            if isAlignedLeft then\n                attemptToAlignLeft\n\n            else\n                attemptToAlignRight\n\n        ToRightOf ->\n            if viewport.window.height - viewport.parent.y < 400 then\n                menuOnRightBottomAligned\n\n            else\n                menuOnRightTopAligned\n\n\npx : Float -> String\npx float =\n    String.fromFloat float ++ \"px\"\n"
}

export const Broadcast = {
   moduleName: "Broadcast",
   path: "/Broadcast.elm",
   contents: "module Broadcast exposing (Msg(..))\n\n{-| This is a module that is special for elm-prefab.\n\nThe `Msg` here can be broadcasted globally to any page that is listening.\n\nTo broadcast a message, you'd do this in your `update` function:\n\n    Effect.broadcast Broadcast.LogOut\n\nAnd to listen for this message, in your subscriptions, you'd have\n\n    Listen.broadcast\n        (\\broadcastMsg ->\n            case broadcastMsg of\n                Broadcast.LogOut ->\n                    -- You can choose which messages you opt in to.\n                    Nothing\n        )\n\n-}\n\n\ntype Msg\n    = LogOut\n"
}

export const Effect = {
   moduleName: "Effect",
   path: "/Effect.elm",
   contents: "module Effect exposing\n    ( Effect(..), none, batch, map\n    , now, nowAfter\n    , sendMsg, sendMsgAfter\n    , Expect(..), UrlBase(..)\n    , toCmd\n    )\n\n{-|\n\n@docs Effect, none, batch, map\n\n\n# Time\n\n@docs now, nowAfter\n\n\n# Callbacks\n\n@docs sendMsg, sendMsgAfter\n\n\n# Internal Http Details\n\n@docs Expect, UrlBase\n\n\n# Effects\n\n@docs toCmd\n\n-}\n\nimport App.Page.Id\nimport App.View.Id\nimport Broadcast\nimport Browser.Dom\nimport Browser.Navigation\nimport Bytes\nimport Bytes.Decode\nimport File\nimport File.Select\nimport Http\nimport Json.Decode\nimport Json.Encode\nimport Process\nimport Random\nimport Task\nimport Time\n\n\nnone : Effect msg\nnone =\n    None\n\n\nbatch : List (Effect msg) -> Effect msg\nbatch =\n    Batch\n\n\nsendMsg : msg -> Effect msg\nsendMsg =\n    SendMsg\n\n\nsendMsgAfter : Int -> msg -> Effect msg\nsendMsgAfter delay msg =\n    SendMsgAfter delay msg\n\n\n{-| Get the current time\n-}\nnow : (Time.Posix -> msg) -> Effect msg\nnow =\n    Now Nothing\n\n\n{-| Delay for some number of milliseconds, then get the current time\n-}\nnowAfter : Float -> (Time.Posix -> msg) -> Effect msg\nnowAfter wait =\n    Now (Just wait)\n\n\ntype Effect msg\n    = None\n    | Batch (List (Effect msg))\n      --\n    | SendMsg msg\n    | SendMsgAfter Int msg\n      -- Random generation\n    | Generate (Random.Generator msg)\n      -- Time\n    | Now (Maybe Float) (Time.Posix -> msg)\n      -- Focus/Blur\n    | Focus String (Result Browser.Dom.Error () -> msg)\n    | Blur String (Result Browser.Dom.Error () -> msg)\n      -- Urls\n    | PushUrl String\n    | ReplaceUrl String\n      -- Files\n    | File (List String) (File.File -> msg)\n    | Files (List String) (File.File -> List File.File -> msg)\n    | FileToUrl File.File (String -> msg)\n      -- Loading\n    | ViewUpdated (App.View.Id.Operation App.Page.Id.Id)\n      -- Browser Navigation\n    | Preload App.Page.Id.Id\n    | Load String\n    | Reload\n    | ReloadAndSkipCache\n      -- History navigation\n    | Forward Int\n    | Back Int\n      -- Http\n    | HttpRequest (RequestDetails msg)\n    | SendBroadcast Broadcast.Msg\n      -- JS interop\n    | SendToWorld\n        { toPort : Json.Encode.Value -> Cmd msg\n        , portName : String\n        , payload : Json.Encode.Value\n        }\n\n\ntype alias RequestDetails msg =\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , urlBase : Maybe UrlBase\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n\n\n{-| This type is here if you want to do something like include special headers for your API\n\nOr switch out urls depending on how the app is configured.\n\n-}\ntype UrlBase\n    = UrlApi\n    | UrlStaticFile\n    | UrlCustom String\n\n\ntype Expect msg\n    = ExpectString (Result Http.Error String -> msg)\n    | ExpectStringResponse (Http.Response String -> msg)\n    | ExpectJson (Json.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectBytes (Bytes.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectBytesResponse (Http.Response Bytes.Bytes -> msg)\n    | ExpectWhatever (Result Http.Error () -> msg)\n\n\ntoCmd :\n    { navKey : Browser.Navigation.Key\n    , preload : App.Page.Id.Id -> msg\n    , dropPageCache : msg\n    , viewRequested : App.View.Id.Operation App.Page.Id.Id -> msg\n    , broadcast : Broadcast.Msg -> msg\n    }\n    ->\n        (UrlBase\n         ->\n            { headers : List Http.Header\n            , urlBase : String\n            }\n        )\n    -> Effect msg\n    -> Cmd msg\ntoCmd options toHttpTarget effect =\n    case effect of\n        None ->\n            Cmd.none\n\n        Batch effects ->\n            Cmd.batch (List.map (toCmd options toHttpTarget) effects)\n\n        Generate generator ->\n            Random.generate identity generator\n\n        Now Nothing toMsg ->\n            Time.now\n                |> Task.perform toMsg\n\n        Now (Just wait) toMsg ->\n            Process.sleep wait\n                |> Task.andThen\n                    (\\_ -> Time.now)\n                |> Task.perform toMsg\n\n        Focus id toMsg ->\n            Process.sleep 1\n                |> Task.andThen\n                    (\\_ -> Browser.Dom.focus id)\n                |> Task.attempt toMsg\n\n        Blur id toMsg ->\n            Browser.Dom.blur id\n                |> Task.attempt toMsg\n\n        PushUrl url ->\n            Browser.Navigation.pushUrl options.navKey url\n\n        ReplaceUrl url ->\n            Browser.Navigation.replaceUrl options.navKey url\n\n        ViewUpdated op ->\n            Task.succeed ()\n                |> Task.perform\n                    (\\_ ->\n                        options.viewRequested op\n                    )\n\n        Load url ->\n            Browser.Navigation.load url\n\n        Reload ->\n            Browser.Navigation.reload\n\n        ReloadAndSkipCache ->\n            Browser.Navigation.reloadAndSkipCache\n\n        Forward steps ->\n            Browser.Navigation.forward options.navKey steps\n\n        Back steps ->\n            Browser.Navigation.back options.navKey steps\n\n        SendToWorld { toPort, payload } ->\n            toPort payload\n\n        SendBroadcast msg ->\n            Task.succeed msg\n                |> Task.perform options.broadcast\n\n        SendMsg msg ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> msg)\n\n        SendMsgAfter delay msg ->\n            Process.sleep (toFloat delay)\n                |> Task.map (\\_ -> msg)\n                |> Task.perform identity\n\n        Preload pageId ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> options.preload pageId)\n\n        File extensions toMsg ->\n            File.Select.file extensions toMsg\n\n        Files extensions toMsg ->\n            File.Select.files extensions toMsg\n\n        FileToUrl fileData toMsg ->\n            File.toUrl fileData\n                |> Task.perform toMsg\n\n        HttpRequest req ->\n            let\n                maybeUrlBase =\n                    Maybe.map toHttpTarget req.urlBase\n            in\n            Http.request\n                { method = req.method\n                , body = req.body\n                , url =\n                    case maybeUrlBase of\n                        Nothing ->\n                            req.url\n\n                        Just base ->\n                            joinPath base.urlBase req.url\n                , headers =\n                    case maybeUrlBase of\n                        Nothing ->\n                            req.headers\n\n                        Just base ->\n                            req.headers ++ base.headers\n                , expect = toHttpExpect req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n\njoinPath : String -> String -> String\njoinPath base path =\n    let\n        baseSlash =\n            String.endsWith \"/\" base\n\n        pathSlash =\n            String.startsWith \"/\" path\n    in\n    if baseSlash && pathSlash then\n        base ++ String.dropLeft 1 path\n\n    else if baseSlash || pathSlash then\n        base ++ path\n\n    else\n        base ++ \"/\" ++ path\n\n\nmap : (a -> b) -> Effect a -> Effect b\nmap f effect =\n    case effect of\n        None ->\n            None\n\n        Batch effects ->\n            Batch (List.map (map f) effects)\n\n        PushUrl url ->\n            PushUrl url\n\n        ReplaceUrl url ->\n            ReplaceUrl url\n\n        ViewUpdated op ->\n            ViewUpdated op\n\n        Load url ->\n            Load url\n\n        Reload ->\n            Reload\n\n        ReloadAndSkipCache ->\n            ReloadAndSkipCache\n\n        Forward n ->\n            Forward n\n\n        Back n ->\n            Back n\n\n        SendToWorld { toPort, portName, payload } ->\n            SendToWorld\n                { toPort = \\val -> Cmd.map f (toPort val)\n                , portName = portName\n                , payload = payload\n                }\n\n        SendBroadcast msg ->\n            SendBroadcast msg\n\n        SendMsg msg ->\n            SendMsg (f msg)\n\n        SendMsgAfter delay msg ->\n            SendMsgAfter delay (f msg)\n\n        Focus id msg ->\n            Focus id (msg >> f)\n\n        Blur id msg ->\n            Blur id (msg >> f)\n\n        Preload route ->\n            Preload route\n\n        HttpRequest req ->\n            HttpRequest\n                { method = req.method\n                , headers = req.headers\n                , url = req.url\n                , urlBase = req.urlBase\n                , body = req.body\n                , expect = mapExpect f req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n        File extensions toMsg ->\n            File extensions (toMsg >> f)\n\n        Files extensions toMsg ->\n            Files extensions (\\top remaining -> toMsg top remaining |> f)\n\n        FileToUrl fileData toMsg ->\n            FileToUrl fileData (toMsg >> f)\n\n        Now maybeWait toMsg ->\n            Now maybeWait (toMsg >> f)\n\n        Generate generator ->\n            Generate (Random.map f generator)\n\n\ntoHttpExpect : Expect msg -> Http.Expect msg\ntoHttpExpect expect =\n    case expect of\n        ExpectString toMsg ->\n            Http.expectString toMsg\n\n        ExpectStringResponse toMsg ->\n            Http.expectStringResponse\n                (\\result ->\n                    case result of\n                        Err err ->\n                            err\n\n                        Ok value ->\n                            value\n                )\n                (\\response ->\n                    Ok (toMsg response)\n                )\n\n        ExpectJson decoder onError ->\n            Http.expectJson\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectBytes decoder onError ->\n            Http.expectBytes\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectBytesResponse toMsg ->\n            Http.expectBytesResponse\n                (\\result ->\n                    case result of\n                        Err err ->\n                            err\n\n                        Ok value ->\n                            value\n                )\n                (\\response ->\n                    Ok (toMsg response)\n                )\n\n        ExpectWhatever toMsg ->\n            Http.expectWhatever toMsg\n\n\nmapExpect : (a -> b) -> Expect a -> Expect b\nmapExpect fn expect =\n    case expect of\n        ExpectString toMsg ->\n            ExpectString (toMsg >> fn)\n\n        ExpectStringResponse toMsg ->\n            ExpectStringResponse (toMsg >> fn)\n\n        ExpectJson decoder onError ->\n            ExpectJson (Json.Decode.map fn decoder) (onError >> fn)\n\n        ExpectBytes decoder onError ->\n            ExpectBytes (Bytes.Decode.map fn decoder) (onError >> fn)\n\n        ExpectBytesResponse toMsg ->\n            ExpectBytesResponse (toMsg >> fn)\n\n        ExpectWhatever toMsg ->\n            ExpectWhatever (toMsg >> fn)\n"
}

export const Listen = {
   moduleName: "Listen",
   path: "/Listen.elm",
   contents: "module Listen exposing\n    ( Listen(..)\n    , none, batch\n    , onKeyPress\n    , onEvery\n    , onResize\n    , map, toSubscription\n    , broadcastListeners\n    )\n\n{-|\n\n\n# Listeners\n\n@docs Listen\n\n@docs none, batch\n\n@docs onKeyPress\n\n@docs onEvery\n\n@docs onResize\n\n@docs map, toSubscription\n\n@docs broadcastListeners\n\n-}\n\nimport Broadcast\nimport Browser.Events\nimport Json.Decode\nimport Platform.Sub\nimport Time\n\n\ntype Listen msg\n    = None\n    | Batch (List (Listen msg))\n      -- Common subscriptions\n    | Every Float (Time.Posix -> msg)\n    | OnWindowResize (Int -> Int -> msg)\n    | OnKeyPress\n        { ctrl : Bool\n        , shift : Bool\n        , key : String\n        }\n        msg\n    | OnBroadcast (Broadcast.Msg -> Maybe msg)\n      --\n    | OnFromJs\n        { portName : String\n        , subscription : Platform.Sub.Sub (Result Json.Decode.Error msg)\n        }\n\n\n{-| -}\nnone : Listen msg\nnone =\n    None\n\n\n{-| -}\nbatch : List (Listen msg) -> Listen msg\nbatch =\n    Batch\n\n\n{-| -}\nonKeyPress : { ctrl : Bool, shift : Bool, key : String } -> msg -> Listen msg\nonKeyPress options msg =\n    OnKeyPress options msg\n\n\n{-| -}\nonEvery : Float -> (Time.Posix -> msg) -> Listen msg\nonEvery ms toMsg =\n    Every ms toMsg\n\n\n{-| -}\nonResize : (Int -> Int -> msg) -> Listen msg\nonResize msg =\n    OnWindowResize msg\n\n\n{-| -}\nmap : (a -> b) -> Listen a -> Listen b\nmap func sub =\n    case sub of\n        None ->\n            None\n\n        Batch subs ->\n            Batch (List.map (map func) subs)\n\n        Every ms toMsg ->\n            Every ms (func << toMsg)\n\n        OnKeyPress options msg ->\n            OnKeyPress options (func msg)\n\n        OnWindowResize msg ->\n            OnWindowResize (\\w h -> func <| msg w h)\n\n        OnBroadcast toMsg ->\n            OnBroadcast (Maybe.map func << toMsg)\n\n        OnFromJs fromJs ->\n            OnFromJs\n                { portName = fromJs.portName\n                , subscription =\n                    Sub.map (Result.map func) fromJs.subscription\n                }\n\n\n{-| -}\ntoSubscription : { ignore : String -> msg } -> Listen msg -> Platform.Sub.Sub msg\ntoSubscription options sub =\n    case sub of\n        None ->\n            Platform.Sub.none\n\n        Batch subs ->\n            Platform.Sub.batch (List.map (toSubscription options) subs)\n\n        Every ms toMsg ->\n            Time.every ms toMsg\n\n        OnWindowResize toMsg ->\n            Browser.Events.onResize toMsg\n\n        OnKeyPress keyOptions msg ->\n            Browser.Events.onKeyDown\n                (Json.Decode.map4\n                    (\\_ ctrl shift meta ->\n                        { ctrl = ctrl\n                        , shift = shift\n                        , meta = meta\n                        }\n                    )\n                    (Json.Decode.field \"key\" Json.Decode.string\n                        |> Json.Decode.andThen\n                            (\\key ->\n                                if String.toLower key == String.toLower keyOptions.key then\n                                    Json.Decode.succeed True\n\n                                else\n                                    Json.Decode.fail \"Not a match\"\n                            )\n                    )\n                    (Json.Decode.field \"ctrlKey\" Json.Decode.bool)\n                    (Json.Decode.field \"shiftKey\" Json.Decode.bool)\n                    (Json.Decode.field \"metaKey\" Json.Decode.bool)\n                    |> Json.Decode.andThen\n                        (\\event ->\n                            -- accept both \"meta\" (Cmd on macs)\n                            --  and \"ctrl\"\n                            if (keyOptions.ctrl == event.ctrl || keyOptions.ctrl == event.meta) && keyOptions.shift == event.shift then\n                                Json.Decode.succeed msg\n\n                            else\n                                Json.Decode.fail \"Not a match\"\n                        )\n                )\n\n        OnBroadcast toMsg ->\n            -- This isn't handled like a normal subscription\n            -- We use `broadcastListeners` to handle this\n            Sub.none\n\n        OnFromJs fromJs ->\n            fromJs.subscription\n                |> Sub.map\n                    (\\result ->\n                        case result of\n                            Ok success ->\n                                success\n\n                            Err err ->\n                                options.ignore (Json.Decode.errorToString err)\n                    )\n\n\n{-| You shouldn't need to use this directly, it's used by some code that elm-prefab generates.\n-}\nbroadcastListeners : Broadcast.Msg -> Listen msg -> List msg\nbroadcastListeners broadcastMsg sub =\n    case sub of\n        None ->\n            []\n\n        Batch subs ->\n            List.concatMap (broadcastListeners broadcastMsg) subs\n\n        Every _ _ ->\n            []\n\n        OnWindowResize _ ->\n            []\n\n        OnKeyPress _ _ ->\n            []\n\n        OnBroadcast toMsg ->\n            case toMsg broadcastMsg of\n                Just msg ->\n                    [ msg ]\n\n                Nothing ->\n                    []\n\n        OnFromJs _ ->\n            []\n"
}

export const all = [
  App_Page_Error,
  App_View,
  Effect_Clipboard,
  Effect_Debounce,
  Effect_File,
  Effect_Focus,
  Effect_Http,
  Effect_LocalStorage,
  Effect_Nav,
  Effect_Page,
  Effect_Random,
  Listen_LocalStorage,
  WebComponent_Portal,
  Broadcast,
  Effect,
  Listen
]

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => {
   for (const file of all) {
      if (overwrite || (!fs.existsSync(path.join(baseDir, file.path)) && !skip)) {
        const filepath = path.join(baseDir, file.path);
        fs.mkdirSync(path.dirname(filepath), { recursive: true });
        fs.writeFileSync(filepath, file.contents);
        const generated = { outputDir: baseDir, path: filepath}
        Options.addGenerated(summary, generated);
      }
   }
}
