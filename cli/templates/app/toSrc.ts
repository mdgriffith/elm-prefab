
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => { 
  
  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Page/Error.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Page/Error.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Page.Error exposing (Error(..))\n\n{-| You may want to protect a page with a certain error when it is first requested.\n\n  - `NotFound` is built in to `elm-prefab`, so you don't need to capture that here.\n\nCommon errors are\n\n    - Unauthenticated — When you require someone to be signed in in order to see a page.\n    - Permission denied — When you require taht someone is both signed in and has certain permissions.\n\n-}\n\n\ntype Error\n    = Unauthenticated\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/View.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/View.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.View exposing\n    ( View, map\n    , Regions\n    )\n\n{-|\n\n@docs View, map\n\n@docs Regions\n\n-}\n\nimport Html\n\n\ntype alias View msg =\n    { title : String\n    , body : Html.Html msg\n    }\n\n\nmap : (a -> b) -> View a -> View b\nmap fn myView =\n    { title = myView.title\n    , body = Html.map fn myView.body\n    }\n\n\n\n{- Regions -}\n\n\n{-| -}\ntype alias Regions view =\n    { primary : Maybe view\n    , detail : List view\n    }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Sub/LocalStorage.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Sub/LocalStorage.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Sub.LocalStorage exposing (..)\n\nimport Json.Decode\nimport Json.Encode\nimport Platform.Sub\nimport Sub\n\n\nport localStorageUpdated : (Json.Encode.Value -> msg) -> Platform.Sub.Sub msg\n\n\nonUpdated :\n    { key : String\n    , decoder : Json.Decode.Decoder msg\n    }\n    -> Sub.Sub msg\nonUpdated options =\n    Sub.OnFromJs\n        { portName = \"localStorageUpdated\"\n        , subscription =\n            localStorageUpdated\n                (Json.Decode.decodeValue options.decoder)\n        }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Main.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Main.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Main exposing (main)\n\n{-| -}\n\nimport App\nimport App.Page.Id\nimport App.Resources\nimport App.Route\nimport App.View.Id\nimport Browser\nimport Effect\nimport Sub\nimport Url\n\n\ntype alias Model =\n    {}\n\n\n{-| -}\nmain : App.App Model Msg\nmain =\n    App.app\n        { init =\n            \\resources flags url ->\n                gotoUrl url {} Effect.none\n        , onUrlChange = UrlChanged\n        , onUrlRequest = UrlRequested\n        , update = update\n        , subscriptions =\n            \\resources model -> Sub.none\n        , toCmd =\n            \\resources options model effect ->\n                Effect.toCmd options effect\n        , toSub =\n            \\resources options model sub ->\n                Sub.toSubscription options sub\n        , view =\n            \\resources toAppMsg model regions ->\n                case regions.primary of\n                    Nothing ->\n                        { title = \"Loading\"\n                        , body = []\n                        }\n\n                    Just (App.Loading _) ->\n                        { title = \"Loading\"\n                        , body = []\n                        }\n\n                    Just App.NotFound ->\n                        { title = \"Not found\"\n                        , body = []\n                        }\n\n                    Just (App.Error error) ->\n                        { title = \"Error\"\n                        , body = []\n                        }\n\n                    Just (App.View pageContent) ->\n                        { title = pageContent.title\n                        , body = [ pageContent.body ]\n                        }\n        }\n\n\ntype Msg\n    = UrlRequested Browser.UrlRequest\n    | UrlChanged Url.Url\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, App.Effect.Effect Msg )\nupdate resources msg model =\n    case msg of\n        UrlRequested (Browser.Internal url) ->\n            ( model, App.Effect.pushUrl (Url.toString url) )\n\n        UrlRequested (Browser.External urlStr) ->\n            ( model, App.Effect.load urlStr )\n\n        UrlChanged url ->\n            gotoUrl url model App.Effect.none\n\n\ngotoUrl : Url.Url -> Model -> App.Effect.Effect Msg -> ( Model, App.Effect.Effect Msg )\ngotoUrl url model eff =\n    case App.Route.parse url of\n        Nothing ->\n            ( model\n            , eff\n            )\n\n        Just { isRedirect, route } ->\n            if isRedirect then\n                ( model\n                , App.Effect.replaceUrl (App.Route.toString route)\n                )\n\n            else\n                case App.Page.Id.fromRoute route of\n                    Nothing ->\n                        ( model, App.Effect.none )\n\n                    Just pageId ->\n                        ( model\n                        , App.Effect.batch\n                            [ App.Effect.loadAt App.View.Id.Primary pageId\n                            , eff\n                            ]\n                        )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Sub.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Sub.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Sub exposing\n    ( Sub(..)\n    , none, batch\n    , onKeyPress\n    , onEvery\n    , onResize\n    , map, toSubscription\n    )\n\n{-|\n\n\n# Subscriptions\n\n@docs Sub\n\n@docs none, batch\n\n@docs onKeyPress\n\n@docs onEvery\n\n@docs onResize\n\n@docs map, toSubscription\n\n-}\n\nimport Browser.Events\nimport Json.Decode\nimport Platform.Sub\nimport Time\n\n\ntype Sub msg\n    = None\n    | Batch (List (Sub msg))\n      -- Common subscriptions\n    | Every Float (Time.Posix -> msg)\n    | OnWindowResize (Int -> Int -> msg)\n    | OnKeyPress\n        { ctrl : Bool\n        , shift : Bool\n        , key : String\n        }\n        msg\n      --\n    | OnFromJs\n        { portName : String\n        , subscription : Platform.Sub.Sub (Result msg Json.Decode.Error)\n        }\n\n\n{-| -}\nnone : Sub msg\nnone =\n    None\n\n\n{-| -}\nbatch : List (Sub msg) -> Sub msg\nbatch =\n    Batch\n\n\n{-| -}\nonKeyPress : { ctrl : Bool, shift : Bool, key : String } -> msg -> Sub msg\nonKeyPress options msg =\n    OnKeyPress options msg\n\n\n{-| -}\nonEvery : Float -> (Time.Posix -> msg) -> Sub msg\nonEvery ms toMsg =\n    Every ms toMsg\n\n\n{-| -}\nonResize : (Int -> Int -> msg) -> Sub msg\nonResize msg =\n    OnWindowResize msg\n\n\n{-| -}\nmap : (a -> b) -> Sub a -> Sub b\nmap func sub =\n    case sub of\n        None ->\n            None\n\n        Batch subs ->\n            Batch (List.map (map func) subs)\n\n        Every ms toMsg ->\n            Every ms (func << toMsg)\n\n        OnKeyPress options msg ->\n            OnKeyPress options (func msg)\n\n        OnWindowResize msg ->\n            OnWindowResize (\\w h -> func <| msg w h)\n\n        OnFromJs fromJs ->\n            OnFromJs\n                { portName = fromJs.portName\n                , subscription =\n                    Sub.map (Result.map toMsg) fromJs.subscription\n                }\n\n\n{-| -}\ntoSubscription : { ignore : String -> msg } -> Sub msg -> Platform.Sub.Sub msg\ntoSubscription options sub =\n    case sub of\n        None ->\n            Platform.Sub.none\n\n        Batch subs ->\n            Platform.Sub.batch (List.map (toSubscription options) subs)\n\n        Every ms toMsg ->\n            Time.every ms toMsg\n\n        OnWindowResize toMsg ->\n            Browser.Events.onResize toMsg\n\n        OnKeyPress keyOptions msg ->\n            Browser.Events.onKeyDown\n                (Json.Decode.map4\n                    (\\_ ctrl shift meta ->\n                        { ctrl = ctrl\n                        , shift = shift\n                        , meta = meta\n                        }\n                    )\n                    (Json.Decode.field \"key\" Json.Decode.string\n                        |> Json.Decode.andThen\n                            (\\key ->\n                                if String.toLower key == String.toLower keyOptions.key then\n                                    Json.Decode.succeed True\n\n                                else\n                                    Json.Decode.fail \"Not a match\"\n                            )\n                    )\n                    (Json.Decode.field \"ctrlKey\" Json.Decode.bool)\n                    (Json.Decode.field \"shiftKey\" Json.Decode.bool)\n                    (Json.Decode.field \"metaKey\" Json.Decode.bool)\n                    |> Json.Decode.andThen\n                        (\\event ->\n                            -- accept both \"meta\" (Cmd on macs)\n                            --  and \"ctrl\"\n                            if (keyOptions.ctrl == event.ctrl || keyOptions.ctrl == event.meta) && keyOptions.shift == event.shift then\n                                Json.Decode.succeed msg\n\n                            else\n                                Json.Decode.fail \"Not a match\"\n                        )\n                )\n\n        OnFromJs fromJs ->\n            fromJs.subscription\n                |> Sub.map\n                    (\\result ->\n                        case result of\n                            Ok success ->\n                                success\n\n                            Err err ->\n                                options.ignore (Json.Decode.errorToString err)\n                    )\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }
}
