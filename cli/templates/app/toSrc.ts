
import * as path from "path";
import * as fs from "fs";
import * as Options from "../../options";

export const copyTo = (baseDir: string, overwrite: boolean, skip: boolean, summary: Options.Summary) => { 
  
  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Page/Error.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Page/Error.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.Page.Error exposing (Error(..))\n\n{-| You may want to protect a page with a certain error when it is first requested.\n\n  - `NotFound` is built in to `elm-prefab`, so you don't need to capture that here.\n\nCommon errors are\n\n    - Unauthenticated — When you require someone to be signed in in order to see a page.\n    - Permission denied — When you require taht someone is both signed in and has certain permissions.\n\n-}\n\n\ntype Error\n    = Unauthenticated\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Effect.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Effect.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "port module App.Effect exposing\n    ( Effect, none, batch, map\n    , now, nowAfter\n    , navigateTo, pushUrl, replaceUrl\n    , forward, back\n    , preload, load, loadAt, reload, clear\n    , sendMsg, sendMsgAfter\n    , saveToLocalStorage, clearLocalStorageKey\n    , generate\n    , focus, blur\n    , file, files, fileToUrl\n    , copyToClipboard\n    , get, request, Expect, expectString, expectJson, expectBytes, expectWhatever\n    , toCmd, sendToJs, sendToResource\n    )\n\n{-|\n\n@docs Effect, none, batch, map\n\n\n# Time\n\n@docs now, nowAfter\n\n\n# Navigation\n\n@docs navigateTo, pushUrl, replaceUrl\n\n@docs forward, back\n\n\n# Loading\n\n@docs preload, load, loadAt, reload, clear\n\n\n# Callbacks\n\n@docs sendMsg, sendMsgAfter\n\n\n# Local Storage\n\n@docs saveToLocalStorage, clearLocalStorageKey\n\n\n# Random generation\n\n@docs generate\n\n\n# Browser focus\n\n@docs focus, blur\n\n\n# File selection\n\n@docs file, files, fileToUrl\n\n\n# Clipboard\n\n@docs copyToClipboard\n\n\n# Http\n\n@docs get, request, Expect, expectString, expectJson, expectBytes, expectWhatever\n\n\n# Effects\n\n@docs toCmd, sendToJs, sendToResource\n\n-}\n\nimport App.Page.Id\nimport App.Resource.Msg\nimport App.Route\nimport App.View.Id\nimport Browser\nimport Browser.Dom\nimport Browser.Navigation\nimport Bytes\nimport Bytes.Decode\nimport File\nimport File.Select\nimport Html\nimport Http\nimport Json.Decode\nimport Json.Encode\nimport Process\nimport Random\nimport Task\nimport Time\n\n\nnone : Effect msg\nnone =\n    None\n\n\nbatch : List (Effect msg) -> Effect msg\nbatch =\n    Batch\n\n\n{-| -}\nnavigateTo : App.Route.Route -> Effect msg\nnavigateTo route =\n    PushUrl (App.Route.toString route)\n\n\n{-| -}\npushUrl : String -> Effect msg\npushUrl =\n    PushUrl\n\n\n{-| -}\nreplaceUrl : String -> Effect msg\nreplaceUrl =\n    ReplaceUrl\n\n\n{-| -}\nload : String -> Effect msg\nload =\n    Load\n\n\n{-| -}\nloadAt : App.View.Id.Region -> App.Page.Id.Id -> Effect msg\nloadAt region pageId =\n    ViewUpdated (App.View.Id.Push region pageId)\n\n\nclear : App.View.Id.Region -> Effect msg\nclear region =\n    ViewUpdated (App.View.Id.ClearRegion region)\n\n\npreload : App.Page.Id.Id -> Effect msg\npreload =\n    Preload\n\n\nreload : Effect msg\nreload =\n    Reload\n\n\nforward : Int -> Effect msg\nforward =\n    Forward\n\n\nback : Int -> Effect msg\nback =\n    Back\n\n\nsendToResource : App.Resource.Msg.Msg -> Effect msg\nsendToResource =\n    SendToResource\n\n\nsendMsg : msg -> Effect msg\nsendMsg =\n    SendMsg\n\n\nsendMsgAfter : Int -> msg -> Effect msg\nsendMsgAfter delay msg =\n    SendMsgAfter delay msg\n\n\n{-| -}\nsendToJs : { tag : String, details : Maybe Json.Encode.Value } -> Effect msg\nsendToJs =\n    SendToWorld\n\n\n{-| -}\nsaveToLocalStorage : String -> Json.Encode.Value -> Effect msg\nsaveToLocalStorage key value =\n    SendToWorld\n        { tag = \"local-storage\"\n        , details =\n            Just\n                (Json.Encode.object\n                    [ ( \"key\", Json.Encode.string key )\n                    , ( \"value\", value )\n                    ]\n                )\n        }\n\n\n{-| -}\nclearLocalStorageKey : String -> Effect msg\nclearLocalStorageKey key =\n    SendToWorld\n        { tag = \"local-storage-clear\"\n        , details =\n            Just\n                (Json.Encode.object\n                    [ ( \"key\", Json.Encode.string key )\n                    ]\n                )\n        }\n\n\n{-| Get the current time\n-}\nnow : (Time.Posix -> msg) -> Effect msg\nnow =\n    Now Nothing\n\n\n{-| Delay for some number of milliseconds, then get the current time\n-}\nnowAfter : Float -> (Time.Posix -> msg) -> Effect msg\nnowAfter wait =\n    Now (Just wait)\n\n\n{-| Attempt to change the browser focus to the element with a given id.\n-}\nfocus : String -> (Result Browser.Dom.Error () -> msg) -> Effect msg\nfocus =\n    Focus\n\n\n{-| Make a specific element lose focus.\n-}\nblur : String -> (Result Browser.Dom.Error () -> msg) -> Effect msg\nblur =\n    Blur\n\n\n{-| Run a random generator to produce a value.\n-}\ngenerate : (item -> msg) -> Random.Generator item -> Effect msg\ngenerate fn generator =\n    Generate (Random.map fn generator)\n\n\n{-| -}\nfile : List String -> (File.File -> msg) -> Effect msg\nfile =\n    File\n\n\nfiles : List String -> (File.File -> List File.File -> msg) -> Effect msg\nfiles =\n    Files\n\n\nfileToUrl : File.File -> (String -> msg) -> Effect msg\nfileToUrl fileData toMsg =\n    FileToUrl fileData toMsg\n\n\ncopyToClipboard : String -> Effect msg\ncopyToClipboard text =\n    SendToWorld\n        { tag = \"copy-to-clipboard\"\n        , details = Just (Json.Encode.string text)\n        }\n\n\nget : String -> Expect msg -> Effect msg\nget url expect =\n    request\n        { method = \"GET\"\n        , headers = []\n        , url = url\n        , body = Http.emptyBody\n        , expect = expect\n        , timeout = Nothing\n        , tracker = Nothing\n        }\n\n\nrequest :\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n    -> Effect msg\nrequest options =\n    HttpRequest options\n\n\ntype Effect msg\n    = None\n    | Batch (List (Effect msg))\n      --\n    | SendMsg msg\n    | SendMsgAfter Int msg\n      -- Random generation\n    | Generate (Random.Generator msg)\n      -- Time\n    | Now (Maybe Float) (Time.Posix -> msg)\n      -- Focus/Blur\n    | Focus String (Result Browser.Dom.Error () -> msg)\n    | Blur String (Result Browser.Dom.Error () -> msg)\n      -- Urls\n    | PushUrl String\n    | ReplaceUrl String\n      -- Files\n    | File (List String) (File.File -> msg)\n    | Files (List String) (File.File -> List File.File -> msg)\n    | FileToUrl File.File (String -> msg)\n      -- Loading\n    | ViewUpdated (App.View.Id.Operation App.Page.Id.Id)\n    | Preload App.Page.Id.Id\n    | Load String\n    | Reload\n      -- History navigation\n    | Forward Int\n    | Back Int\n      -- Http\n    | HttpRequest (RequestDetails msg)\n      -- JS interop\n    | SendToWorld\n        { tag : String\n        , details : Maybe Json.Encode.Value\n        }\n    | SendToResource App.Resource.Msg.Msg\n\n\ntype alias RequestDetails msg =\n    { method : String\n    , headers : List Http.Header\n    , url : String\n    , body : Http.Body\n    , expect : Expect msg\n    , timeout : Maybe Float\n    , tracker : Maybe String\n    }\n\n\ntype Expect msg\n    = ExpectString (Result Http.Error String -> msg)\n    | ExpectJson (Json.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectBytes (Bytes.Decode.Decoder msg) (Http.Error -> msg)\n    | ExpectWhatever (Result Http.Error () -> msg)\n\n\nexpectString : (Result Http.Error String -> msg) -> Expect msg\nexpectString =\n    ExpectString\n\n\nexpectJson : Json.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectJson =\n    ExpectJson\n\n\nexpectBytes : Bytes.Decode.Decoder msg -> (Http.Error -> msg) -> Expect msg\nexpectBytes =\n    ExpectBytes\n\n\nexpectWhatever : (Result Http.Error () -> msg) -> Expect msg\nexpectWhatever =\n    ExpectWhatever\n\n\nport outgoing : { tag : String, details : Maybe Json.Encode.Value } -> Cmd msg\n\n\ntoCmd :\n    { options\n        | navKey : Browser.Navigation.Key\n        , preload : App.Page.Id.Id -> msg\n        , sendToResource : App.Resource.Msg.Msg -> msg\n        , dropPageCache : msg\n        , viewRequested : App.View.Id.Operation App.Page.Id.Id -> msg\n    }\n    -> Effect msg\n    -> Cmd msg\ntoCmd options effect =\n    case effect of\n        None ->\n            Cmd.none\n\n        Batch effects ->\n            Cmd.batch (List.map (toCmd options) effects)\n\n        Generate generator ->\n            Random.generate identity generator\n\n        Now Nothing toMsg ->\n            Time.now\n                |> Task.perform toMsg\n\n        Now (Just wait) toMsg ->\n            Process.sleep wait\n                |> Task.andThen\n                    (\\_ -> Time.now)\n                |> Task.perform toMsg\n\n        Focus id toMsg ->\n            Process.sleep 1\n                |> Task.andThen\n                    (\\_ -> Browser.Dom.focus id)\n                |> Task.attempt toMsg\n\n        Blur id toMsg ->\n            Browser.Dom.blur id\n                |> Task.attempt toMsg\n\n        PushUrl url ->\n            Browser.Navigation.pushUrl options.navKey url\n\n        ReplaceUrl url ->\n            Browser.Navigation.replaceUrl options.navKey url\n\n        ViewUpdated op ->\n            Task.succeed ()\n                |> Task.perform\n                    (\\_ ->\n                        options.viewRequested op\n                    )\n\n        Load url ->\n            Browser.Navigation.load url\n\n        Reload ->\n            Browser.Navigation.reload\n\n        Forward steps ->\n            Browser.Navigation.forward options.navKey steps\n\n        Back steps ->\n            Browser.Navigation.back options.navKey steps\n\n        SendToWorld outgoingMsg ->\n            outgoing outgoingMsg\n\n        SendToResource resourceMsg ->\n            Task.succeed ()\n                |> Task.perform\n                    (\\_ ->\n                        options.sendToResource resourceMsg\n                    )\n\n        SendMsg msg ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> msg)\n\n        SendMsgAfter delay msg ->\n            Process.sleep (toFloat delay)\n                |> Task.map (\\_ -> msg)\n                |> Task.perform identity\n\n        Preload pageId ->\n            Task.succeed ()\n                |> Task.perform (\\_ -> options.preload pageId)\n\n        File extensions toMsg ->\n            File.Select.file extensions toMsg\n\n        Files extensions toMsg ->\n            File.Select.files extensions toMsg\n\n        FileToUrl fileData toMsg ->\n            File.toUrl fileData\n                |> Task.perform toMsg\n\n        HttpRequest req ->\n            Http.request\n                { method = req.method\n                , body = req.body\n                , url = req.url\n                , headers = req.headers\n                , expect = toHttpExpect req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n\nmap : (a -> b) -> Effect a -> Effect b\nmap f effect =\n    case effect of\n        None ->\n            None\n\n        Batch effects ->\n            Batch (List.map (map f) effects)\n\n        PushUrl url ->\n            PushUrl url\n\n        ReplaceUrl url ->\n            ReplaceUrl url\n\n        ViewUpdated op ->\n            ViewUpdated op\n\n        Load url ->\n            Load url\n\n        Reload ->\n            Reload\n\n        Forward n ->\n            Forward n\n\n        Back n ->\n            Back n\n\n        SendToResource msg ->\n            SendToResource msg\n\n        SendToWorld { tag, details } ->\n            SendToWorld { tag = tag, details = details }\n\n        SendMsg msg ->\n            SendMsg (f msg)\n\n        SendMsgAfter delay msg ->\n            SendMsgAfter delay (f msg)\n\n        Focus id msg ->\n            Focus id (msg >> f)\n\n        Blur id msg ->\n            Blur id (msg >> f)\n\n        Preload route ->\n            Preload route\n\n        HttpRequest req ->\n            HttpRequest\n                { method = req.method\n                , headers = req.headers\n                , url = req.url\n                , body = req.body\n                , expect = mapExpect f req.expect\n                , timeout = req.timeout\n                , tracker = req.tracker\n                }\n\n        File extensions toMsg ->\n            File extensions (toMsg >> f)\n\n        Files extensions toMsg ->\n            Files extensions (\\top remaining -> toMsg top remaining |> f)\n\n        FileToUrl fileData toMsg ->\n            FileToUrl fileData (toMsg >> f)\n\n        Now maybeWait toMsg ->\n            Now maybeWait (toMsg >> f)\n\n        Generate generator ->\n            Generate (Random.map f generator)\n\n\ntoHttpExpect : Expect msg -> Http.Expect msg\ntoHttpExpect expect =\n    case expect of\n        ExpectString toMsg ->\n            Http.expectString toMsg\n\n        ExpectJson decoder onError ->\n            Http.expectJson\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectBytes decoder onError ->\n            Http.expectBytes\n                (\\result ->\n                    case result of\n                        Err err ->\n                            onError err\n\n                        Ok value ->\n                            value\n                )\n                decoder\n\n        ExpectWhatever toMsg ->\n            Http.expectWhatever toMsg\n\n\nmapExpect : (a -> b) -> Expect a -> Expect b\nmapExpect fn expect =\n    case expect of\n        ExpectString toMsg ->\n            ExpectString (toMsg >> fn)\n\n        ExpectJson decoder onError ->\n            ExpectJson (Json.Decode.map fn decoder) (onError >> fn)\n\n        ExpectBytes decoder onError ->\n            ExpectBytes (Bytes.Decode.map fn decoder) (onError >> fn)\n\n        ExpectWhatever toMsg ->\n            ExpectWhatever (toMsg >> fn)\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/Sub.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/Sub.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "port module App.Sub exposing\n    ( Sub\n    , none, batch\n    , onKeyPress\n    , every\n    , onResize, onLocalStorageUpdated\n    , map, toSubscription\n    , onResourceUpdated, toResourceListeners\n    )\n\n{-|\n\n\n# Subscriptions\n\n@docs Sub\n\n@docs none, batch\n\n@docs onKeyPress\n\n@docs every\n\n@docs onResize, onLocalStorageUpdated\n\n@docs map, toSubscription\n\n@docs onResourceUpdated, toResourceListeners\n\n-}\n\nimport App.Resource.Msg\nimport Browser.Events\nimport Json.Decode\nimport Json.Encode\nimport Platform.Sub\nimport Time\n\n\ntype Sub msg\n    = None\n    | Batch (List (Sub msg))\n      -- Common subscriptions\n    | Every Float (Time.Posix -> msg)\n    | OnWindowResize (Int -> Int -> msg)\n    | OnKeyPress\n        { ctrl : Bool\n        , shift : Bool\n        , key : String\n        }\n        msg\n    | OnResourceUpdated (App.Resource.Msg.Msg -> Maybe msg)\n      --\n    | OnLocalStorageUpdated\n        { key : String\n        , decoder : Json.Decode.Decoder msg\n        }\n\n\n{-| -}\nnone : Sub msg\nnone =\n    None\n\n\n{-| -}\nbatch : List (Sub msg) -> Sub msg\nbatch =\n    Batch\n\n\n{-| -}\nonKeyPress : { ctrl : Bool, shift : Bool, key : String } -> msg -> Sub msg\nonKeyPress options msg =\n    OnKeyPress options msg\n\n\n{-| -}\nevery : Float -> (Time.Posix -> msg) -> Sub msg\nevery ms toMsg =\n    Every ms toMsg\n\n\n{-| -}\nonResize : (Int -> Int -> msg) -> Sub msg\nonResize msg =\n    OnWindowResize msg\n\n\n{-| Use `App.Resources.listen` to listen to resource updates.\n\nIt's just slightly more convenient than using `onResourceUpdated` directly.\n\n-}\nonResourceUpdated : (App.Resource.Msg.Msg -> Maybe msg) -> Sub msg\nonResourceUpdated =\n    OnResourceUpdated\n\n\nonLocalStorageUpdated :\n    { key : String\n    , decoder : Json.Decode.Decoder msg\n    }\n    -> Sub msg\nonLocalStorageUpdated options =\n    OnLocalStorageUpdated options\n\n\n{-| -}\nmap : (a -> b) -> Sub a -> Sub b\nmap func sub =\n    case sub of\n        None ->\n            None\n\n        Batch subs ->\n            Batch (List.map (map func) subs)\n\n        Every ms toMsg ->\n            Every ms (func << toMsg)\n\n        OnKeyPress options msg ->\n            OnKeyPress options (func msg)\n\n        OnWindowResize msg ->\n            OnWindowResize (\\w h -> func <| msg w h)\n\n        OnResourceUpdated toMaybeMsg ->\n            OnResourceUpdated (Maybe.map func << toMaybeMsg)\n\n        OnLocalStorageUpdated { key, decoder } ->\n            OnLocalStorageUpdated\n                { key = key\n                , decoder = Json.Decode.map func decoder\n                }\n\n\n{-| -}\ntoSubscription : { ignore : String -> msg } -> Sub msg -> Platform.Sub.Sub msg\ntoSubscription options sub =\n    case sub of\n        None ->\n            Platform.Sub.none\n\n        Batch subs ->\n            Platform.Sub.batch (List.map (toSubscription options) subs)\n\n        Every ms toMsg ->\n            Time.every ms toMsg\n\n        OnWindowResize toMsg ->\n            Browser.Events.onResize toMsg\n\n        OnResourceUpdated toMaybeMsg ->\n            Platform.Sub.none\n\n        OnKeyPress keyOptions msg ->\n            Browser.Events.onKeyDown\n                (Json.Decode.map4\n                    (\\_ ctrl shift meta ->\n                        { ctrl = ctrl\n                        , shift = shift\n                        , meta = meta\n                        }\n                    )\n                    (Json.Decode.field \"key\" Json.Decode.string\n                        |> Json.Decode.andThen\n                            (\\key ->\n                                if String.toLower key == String.toLower keyOptions.key then\n                                    Json.Decode.succeed True\n\n                                else\n                                    Json.Decode.fail \"Not a match\"\n                            )\n                    )\n                    (Json.Decode.field \"ctrlKey\" Json.Decode.bool)\n                    (Json.Decode.field \"shiftKey\" Json.Decode.bool)\n                    (Json.Decode.field \"metaKey\" Json.Decode.bool)\n                    |> Json.Decode.andThen\n                        (\\event ->\n                            -- accept both \"meta\" (Cmd on macs)\n                            --  and \"ctrl\"\n                            if (keyOptions.ctrl == event.ctrl || keyOptions.ctrl == event.meta) && keyOptions.shift == event.shift then\n                                Json.Decode.succeed msg\n\n                            else\n                                Json.Decode.fail \"Not a match\"\n                        )\n                )\n\n        OnLocalStorageUpdated { key, decoder } ->\n            localStorageUpdated\n                (\\payload ->\n                    if payload.key == key then\n                        case Json.Decode.decodeValue decoder payload.value of\n                            Ok value ->\n                                value\n\n                            Err _ ->\n                                options.ignore key\n\n                    else\n                        options.ignore key\n                )\n\n\nport localStorageUpdated :\n    ({ key : String\n     , value : Json.Encode.Value\n     }\n     -> msg\n    )\n    -> Platform.Sub.Sub msg\n\n\ntoResourceListeners : App.Resource.Msg.Msg -> Sub msg -> List msg\ntoResourceListeners resource sub =\n    case sub of\n        OnResourceUpdated toMaybeMsg ->\n            case toMaybeMsg resource of\n                Just msg ->\n                    [ msg ]\n\n                Nothing ->\n                    []\n\n        Batch subs ->\n            List.concatMap (toResourceListeners resource) subs\n\n        _ ->\n            []\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/App/View.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/App/View.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module App.View exposing\n    ( View, map\n    , Regions\n    )\n\n{-|\n\n@docs View, map\n\n@docs Regions\n\n-}\n\nimport Html\n\n\ntype alias View msg =\n    { title : String\n    , body : Html.Html msg\n    }\n\n\nmap : (a -> b) -> View a -> View b\nmap fn myView =\n    { title = myView.title\n    , body = Html.map fn myView.body\n    }\n\n\n\n{- Regions -}\n\n\n{-| -}\ntype alias Regions view =\n    { primary : Maybe view\n    , detail : List view\n    }\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }

  if (overwrite || (!fs.existsSync(path.join(baseDir, "/Main.elm")) && !skip)) {
    const filepath = path.join(baseDir, "/Main.elm");
    fs.mkdirSync(path.dirname(filepath), { recursive: true });
    fs.writeFileSync(filepath, "module Main exposing (main)\n\n{-| -}\n\nimport App\nimport App.Effect\nimport App.Page.Id\nimport App.Resources\nimport App.Route\nimport App.Sub\nimport App.View\nimport App.View.Id\nimport Browser\nimport Html\nimport Json.Decode\nimport Json.Encode as Json\nimport Url\n\n\ntype alias Model =\n    {}\n\n\n{-| -}\nmain : App.App Model Msg\nmain =\n    App.app\n        { init = init\n        , onUrlChange = UrlChanged\n        , onUrlRequest = UrlRequested\n        , update = update\n        , subscriptions = subscriptions\n        , toCmd = toCmd\n        , toSub = toSub\n        , view =\n            \\resources toAppMsg model regions ->\n                { title = toTitle regions\n                , body = [ viewLayout resources toAppMsg model regions ]\n                }\n        }\n\n\ntoTitle : App.View.Regions (App.View msg) -> String\ntoTitle regions =\n    case regions.primary of\n        Nothing ->\n            \"Nothing\"\n\n        Just (App.Loading _) ->\n            \"Loading\"\n\n        Just App.NotFound ->\n            \"Not found\"\n\n        Just (App.Error error) ->\n            \"Not found\"\n\n        Just (App.View page) ->\n            page.title\n\n\ninit : App.Resources.Resources -> Json.Value -> Url.Url -> ( Model, App.Effect.Effect Msg )\ninit resources flagsValue url =\n    let\n        initial =\n            App.Route.parse url\n\n        model =\n            {}\n    in\n    gotoUrl url model App.Effect.none\n\n\n\n{-\n   Subscriptions and Commands\n\n-}\n\n\nsubscriptions : App.Resources.Resources -> Model -> App.Sub.Sub Msg\nsubscriptions resources model =\n    App.Sub.none\n\n\ntoSub : App.Resources.Resources -> App.SubOptions Msg -> Model -> App.Sub.Sub (App.Msg Msg) -> Sub.Sub (App.Msg Msg)\ntoSub resources options model sub =\n    App.Sub.toSubscription options sub\n\n\ntoCmd : App.Resources.Resources -> App.CmdOptions Msg -> Model -> App.Effect.Effect (App.Msg Msg) -> Cmd (App.Msg Msg)\ntoCmd resources options model effect =\n    App.Effect.toCmd options effect\n\n\n\n{-\n   Updates\n-}\n\n\ntype Msg\n    = UrlChanged Url.Url\n    | UrlRequested Browser.UrlRequest\n\n\nupdate : App.Resources.Resources -> Msg -> Model -> ( Model, App.Effect.Effect Msg )\nupdate resources msg model =\n    case msg of\n        UrlRequested (Browser.Internal url) ->\n            case App.Route.parse url of\n                Nothing ->\n                    ( model\n                    , App.Effect.none\n                    )\n\n                Just route ->\n                    ( model\n                    , App.Effect.navigateTo route.route\n                    )\n\n        UrlRequested (Browser.External urlStr) ->\n            ( model, App.Effect.pushUrl urlStr )\n\n        UrlChanged url ->\n            gotoUrl url model App.Effect.none\n\n\ngotoUrl : Url.Url -> Model -> App.Effect.Effect Msg -> ( Model, App.Effect.Effect Msg )\ngotoUrl url model eff =\n    case App.Route.parse url of\n        Nothing ->\n            ( model\n            , eff\n            )\n\n        Just route ->\n            gotoRoute route model eff\n\n\ngotoRoute : { isRedirect : Bool, route : App.Route.Route } -> Model -> App.Effect.Effect Msg -> ( Model, App.Effect.Effect Msg )\ngotoRoute { isRedirect, route } model eff =\n    if isRedirect then\n        ( model, App.Effect.replaceUrl (App.Route.toString route) )\n\n    else\n        case App.Page.Id.fromRoute route of\n            Nothing ->\n                ( model, App.Effect.none )\n\n            Just pageId ->\n                ( model\n                , App.Effect.batch\n                    [ App.Effect.loadAt App.View.Id.Primary pageId\n                    , eff\n                    ]\n                )\n\n\n\n{- View -}\n\n\n{-| -}\nviewLayout :\n    App.Resources.Resources\n    -> (Msg -> msg)\n    -> Model\n    -> App.View.Regions (App.View msg)\n    -> Html.Html msg\nviewLayout resources toAppMsg model regions =\n    case regions.primary of\n        Nothing ->\n            Html.text \"\"\n\n        Just region ->\n            viewRegion resources toAppMsg model region\n\n\nviewRegion :\n    App.Resources.Resources\n    -> (Msg -> msg)\n    -> Model\n    -> App.View msg\n    -> Html.Html msg\nviewRegion resources toAppMsg model region =\n    case region of\n        App.Loading _ ->\n            Html.text \"\"\n\n        App.NotFound ->\n            Html.text \"\"\n\n        App.Error error ->\n            Html.text \"\"\n\n        App.View page ->\n            page.body\n");
    const generated = { outputDir: baseDir, path: filepath}
    Options.addGenerated(summary, generated);
  }
}
